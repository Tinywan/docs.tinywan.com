<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>4 - 类型 - 万物联网服务平台</title>
    
    
    
    
</head>
<body>
<div id="root"></div>
<script type="application/payload+json">
{"id":"yWP4GW","summary":[{"id":"","title":"第0章 远程安装","articles":[]},{"id":"","title":"第1章 介绍和安装","articles":[{"title":"1 - 介绍和安装","ref":"\/docs\/golang_tutorial_01.md","path":"\/docs\/golang_tutorial_01.html","children":[]},{"title":"2 - Hello World ","ref":"\/docs\/golang_tutorial_02.md","path":"\/docs\/golang_tutorial_02.html","children":[]}]},{"id":"","title":"第2章 变量、类型和常量","articles":[{"title":"3 - 变量","ref":"\/docs\/golang_tutorial_03.md","path":"\/docs\/golang_tutorial_03.html","children":[]},{"title":"4 - 类型","ref":"\/docs\/golang_tutorial_04.md","path":"\/docs\/golang_tutorial_04.html","children":[]},{"title":"5 - 常量","ref":"\/docs\/golang_tutorial_05.md","path":"\/docs\/golang_tutorial_05.html","children":[]}]},{"id":"","title":"第3章 函数和包","articles":[{"title":"6 - 函数","ref":"\/docs\/golang_tutorial_06.md","path":"\/docs\/golang_tutorial_06.html","children":[]},{"title":"7 - 包","ref":"\/docs\/golang_tutorial_07.md","path":"\/docs\/golang_tutorial_07.html","children":[]}]},{"id":"","title":"第4章 条件和循环语句","articles":[{"title":"8 - if else 语句","ref":"\/docs\/golang_tutorial_08.md","path":"\/docs\/golang_tutorial_08.html","children":[]},{"title":"9 - 循环语句","ref":"\/docs\/golang_tutorial_09.md","path":"\/docs\/golang_tutorial_09.html","children":[]},{"title":"10 - switch语句","ref":"\/docs\/golang_tutorial_10.md","path":"\/docs\/golang_tutorial_10.html","children":[]}]},{"id":"","title":"第5章 数组、切片和变参函数","articles":[{"title":"11 - 数组和切片","ref":"\/docs\/golang_tutorial_11.md","path":"\/docs\/golang_tutorial_11.html","children":[]},{"title":"12 - 变 参函数","ref":"\/docs\/golang_tutorial_12.md","path":"\/docs\/golang_tutorial_12.html","children":[]}]},{"id":"","title":"第6章 更多的类型","articles":[{"title":"13 - Map","ref":"\/docs\/golang_tutorial_13.md","path":"\/docs\/golang_tutorial_13.html","children":[]},{"title":"14 - 字符串","ref":"\/docs\/golang_tutorial_14.md","path":"\/docs\/golang_tutorial_14.html","children":[]}]},{"id":"","title":"第7章 指针、结构体和方法","articles":[{"title":"15 - 指针","ref":"\/docs\/golang_tutorial_15.md","path":"\/docs\/golang_tutorial_15.html","children":[]},{"title":"16 -  结构体","ref":"\/docs\/golang_tutorial_16.md","path":"\/docs\/golang_tutorial_16.html","children":[]},{"title":"17 -  方法","ref":"\/docs\/golang_tutorial_17.md","path":"\/docs\/golang_tutorial_17.html","children":[]}]},{"id":"","title":"第8章 接口","articles":[]},{"id":"","title":"第9章 并发","articles":[{"title":" 21 - 协程","ref":"\/docs\/golang_tutorial_21.md","path":"\/docs\/golang_tutorial_21.html","children":[]}]},{"id":"","title":"第10章 面向对象编程","articles":[]},{"id":"","title":"第11章 延迟和错误处理","articles":[{"title":"35 - 读文件","ref":"\/docs\/golang_tutorial_35.md","path":"\/docs\/golang_tutorial_35.html","children":[]}]},{"id":"","title":"文档","articles":[{"title":"如何编写 Go代码","ref":"\/docs\/how_to_write_go_code.md","path":"\/docs\/how_to_write_go_code.html","children":[]}]}],"config":{"pluginsConfig":{"theme-default":{"auto_open":true,"navs":[{"title":"ThinkAPI","url":"https:\/\/docs.topthink.com\/think-api\/1835085"},{"title":"Tinywan","url":"https:\/\/market.topthink.com\/website"}]}},"title":"万物联网服务平台","plugins":["highlight","comment"],"theme":"classic"},"file":{"path":"\/docs\/golang_tutorial_04.html","content":"4 - 类型\n========================\n\n上一节：[第三篇  变量](\/docs\/golang_tutorial_03.md)   \n下一节：[第五篇  常量](\/docs\/golang_tutorial_05.md)   \n\n这是本Golang系列教程的第四篇。  \n\n下面是 Go 支持的基本类型  \n\n* bool  \n* Numeric Types  \n  * int8, int16, int32, int64, int  \n  * uint8, uint16, uint32, uint64, uint  \n  * float32, float64  \n  * complex64, complex128  \n  * byte  \n  * rune  \n* string\n\n## bool  \n\nbool 类型表示一个布尔值，值为 true 或者 false。  \n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {  \n    a := true\n    b := false\n    fmt.Println(\"a:\", a, \"b:\", b)\n    c := a && b\n    fmt.Println(\"c:\", c)\n    d := a || b\n    fmt.Println(\"d:\", d)\n}\n```\n\n在上面的程序中，a 赋值为 true，b 赋值为 false。  \n\nc 赋值为 a && b。仅当 a 和 b 都为 true 时，操作符 && 才返回 true。因此，在这里 c 为 false。\n\n当 a 或者 b 为 true 时，操作符 || 返回 true。在这里，由于 a 为 true，因此 d 也为 true。\n\n我们将会得到如下输出：  \n\n```golang\na: true b: false  \nc: false  \nd: true \n```\n\n## 有符号整型  \n\nint8：表示 8 位有符号整型  \n大小：8 位  \n范围：`-128～127`  \n\nint16：表示 16 位有符号整型  \n大小：16 位  \n范围：`-32768～32767`  \n\nint32：表示 32 位有符号整型  \n大小：32 位  \n范围：`-2147483648～2147483647`  \n\nint64：表示 64 位有符号整型  \n大小：64 位  \n范围：`-9223372036854775808～9223372036854775807`  \n\nint：根据不同的底层平台（Underlying Platform），表示 32 或 64 位整型。除非对整型的大小有特定的需求，否则你通常应该使用 int 表示整型。  \n大小：在 32 位系统下是 32 位，而在 64 位系统下是 64 位。  \n范围：在 32 位系统下是 `-2147483648～2147483647`，而在 64 位系统是 `-9223372036854775808～9223372036854775807`。  \n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {  \n    var a int = 89\n    b := 95  \/\/ 简短\n    fmt.Println(\"value of a is\", a, \"and b is\", b)\n}\n```\n\n如下输出：  \n\n```golang\nvalue of a is 89 and b is 95\n```\n\n在上述程序中，a 是 int 类型，而 b 的类型通过赋值（95）推断得出。上面我们提到，int 类型的大小在 32 位系统下是 32 位，而在 64 位系统下是 64 位。接下来我们会证实这种说法。  \n\n在 Printf 方法中，使用 `%T` 格式说明符（Format Specifier），可以打印出变量的**类型**。Go 的 unsafe 包提供了一个 Sizeof 函数，该函数接收变量并返回它的字节大小。unsafe 包应该小心使用，因为使用 unsafe 包可能会带来可移植性问题。不过出于本教程的目的，我们是可以使用的。  \n\n下面程序会输出变量 a 和 b 的类型和大小。格式说明符 %T 用于打印类型，而 %d 用于打印字节大小。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n    \"unsafe\"\n)\n\nfunc main() {  \n    var a int = 89\n    b := 95\n    fmt.Println(\"value of a is\", a, \"and b is\", b)\n    fmt.Printf(\"type of a is %T, size of a is %d\", a, unsafe.Sizeof(a)) \/\/type and size of a\n    fmt.Printf(\"\\ntype of b is %T, size of b is %d\", b, unsafe.Sizeof(b)) \/\/type and size of b\n}\n```\n\n以上程序会输出：  \n\n```golang\nvalue of a is 89 and b is 95  \ntype of a is int, size of a is 4  \ntype of b is int, size of b is 4  \n```\n\n从上面的输出，我们可以推断出 a 和 b 为 int 类型，且大小都是 32 位（4 字节）。如果你在 64 位系统上运行上面的代码，会有不同的输出。在 64 位系统下，a 和 b 会占用 64 位（8 字节）的大小。  \n\n以下为windows 64位系统运行结果（非翻译案例）：  \n\n```golang\nvalue of a is 89 and b is 95\ntype of a is int, size of a is 8\ntype of b is int, size of b is 8 \n```\n\n## 无符号整型  \n\nuint8：表示 8 位无符号整型  \n大小：8 位  \n范围：0～255  \n\nuint16：表示 16 位无符号整型  \n大小：16 位  \n范围：0～65535  \n\nuint32：表示 32 位无符号整型  \n大小：32 位  \n范围：0～4294967295  \n\nuint64：表示 64 位无符号整型  \n大小：64 位  \n范围：0～18446744073709551615  \n\nuint：根据不同的底层平台，表示 32 或 64 位无符号整型。  \n大小：在 32 位系统下是 32 位，而在 64 位系统下是 64 位。  \n范围：在 32 位系统下是 0～4294967295，而在 64 位系统是 0～18446744073709551615。  \n\n##  浮点型  \n\nfloat32：32 位浮点数  \nfloat64：64 位浮点数  \n\n下面一个简单程序演示了整型和浮点型的运用。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    a, b := 5.67, 8.97\n    fmt.Printf(\"type of a %T b %T\\n\", a, b)\n    sum := a + b\n    diff := a - b\n    fmt.Println(\"sum\", sum, \"diff\", diff)\n\n    no1, no2 := 56, 89\n    fmt.Println(\"sum\", no1+no2, \"diff\", no1-no2)\n}\n```\n\na 和 b 的类型根据赋值推断得出。在这里，a 和 b 的类型为 float64（float64 是浮点数的默认类型）。我们把 a 和 b 的和赋值给变量 sum，把 b 和 a 的差赋值给 diff，接下来打印 sum 和 diff。no1 和 no2 也进行了相同的计算。上述程序将会输出：  \n\n```golang\ntype of a float64 b float64\nsum 14.64 diff -3.3000000000000007\nsum 145 diff -33\n```\n\n## 复数类型  \n\ncomplex64：实部和虚部都是 float32 类型的的复数。  \ncomplex128：实部和虚部都是 float64 类型的的复数。  \n\n内建函数 complex 用于创建一个包含实部和虚部的复数。complex 函数的定义如下：  \n\n```golang\nfunc complex(r, i FloatType) ComplexType\n```\n\n该函数的参数分别是实部和虚部，并返回一个复数类型。实部和虚部应该是相同类型，也就是 float32 或 float64。如果实部和虚部都是 float32 类型，则函数会返回一个 complex64 类型的复数。如果实部和虚部都是 float64 类型，则函数会返回一个 complex128 类型的复数。  \n\n还可以使用简短语法来创建复数：  \n\n```golang\nc := 6 + 7i\n```\n\n下面我们编写一个简单的程序来理解复数：\n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    c1 := complex(5,7)\n    c2 := 8 + 27i\n    cadd := c1 + c2\n    fmt.Println(\"sum:\",cadd)\n\n    cmul := c1 * c2\n    fmt.Println(\"mul :\",cmul)\n}\n```\n\n在上面的程序里，c1 和 c2 是两个复数。c1的实部为 5，虚部为 7。c2 的实部为8，虚部为 27。c1 和 c2 的和赋值给 cadd ，而 c1 和 c2 的乘积赋值给 cmul。该程序将输出：  \n\n```golang\nsum: (13+34i)\nmul : (-149+191i)\n```\n\n##  其他数字类型  \n\nbyte 是 uint8 的别名。  \nrune 是 int32 的别名。  \n\n在学习字符串的时候，我们会详细讨论 byte 和 rune。  \n\n## string 类型  \n\n在 Golang 中，字符串是字节的集合。如果你现在还不理解这个定义，也没有关系。我们可以暂且认为一个字符串就是由很多字符组成的。我们后面会在一个教程中深入学习字符串。 下面编写一个使用字符串的程序。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    first := \"Wan\"\n    last := \"ShaoBo\"\n    name := first +\" \"+ last\n    fmt.Println(\"My name is\",name)\n}\n```\n\n上面程序中，first 赋值为字符串 \"Naveen\"，last 赋值为字符串 \"Ramanathan\"。+ 操作符可以用于拼接字符串。我们拼接了 first、空格和 last，并将其赋值给 name。  \n\n上述程序将打印输出:\n\n```golang\nMy name is Wan ShaoBo\n```\n\n还有许多应用于字符串上面的操作，我们将会在一个单独的教程里看见它们。  \n\n## 类型转换  \n\nGo 有着非常严格的强类型特征。Go 没有自动类型提升或类型转换。我们通过一个例子说明这意味着什么。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    i := 55      \/\/int\n    j := 67.8    \/\/float64\n    sum := i + j \/\/不允许 int + float64\n    fmt.Println(sum)\n}\n```\n\n上面的代码在 C 语言中是完全合法的，然而在 Go 中，却是行不通的。i 的类型是 int ，而 j 的类型是 float64 ，我们正试图把两个不同类型的数相加，Go 不允许这样的操作。如果运行程序，你会得到   \n\n```golang\n# command-line-arguments\ndemo04\\demo04-07.go:10:14: invalid operation: i + j (mismatched types int and float64)\n```\n\n要修复这个错误，i 和 j 应该是相同的类型。在这里，我们把 j 转换为 int 类型。把 v 转换为 T 类型的语法是 T(v)。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    i := 55      \/\/int\n    j := 67.8    \/\/float64\n    sum := i + int(j) \/\/j is converted to int\n    fmt.Println(sum)\n}\n```\n\n现在，当你运行上面的程序时，会看见输出\n\n```golang\n122\n```\n\n赋值的情况也是如此。把一个变量赋值给另一个不同类型的变量，需要显式的类型转换。下面程序说明了这一点。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    i := 10\n    var j float64 = float64(i) \/\/ 若没有显式转换，该语句会报错\n    fmt.Println(\"j\", j)\n}\n```\n\n在第 9 行，i 转换为 float64 类型，接下来赋值给 j。如果不进行类型转换，当你试图把 i 赋值给 j 时，编译器会抛出错误。  \n\n本文由 [GCTT](https:\/\/github.com\/studygolang\/GCTT) 原创翻译，[Go语言中文网](https:\/\/studygolang.com\/)首发。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","meta":{"mtime":""}}}
</script>

    <script src="../tmp/book/624c24de5f335/asset/lodash/lodash.min.js?v=4.17.21"></script>

    <script src="../tmp/book/624c24de5f335/asset/react/react.production.min.js?v=17.0.2"></script>

    <script src="../tmp/book/624c24de5f335/asset/react-dom/react-dom.production.min.js?v=17.0.2"></script>

    <script src="../tmp/book/624c24de5f335/asset/reader/index.js?v=1.0.24"></script>

    <script src="../tmp/book/624c24de5f335/asset/plugins/comment/index.js?v=0.0.1"></script>

    <script src="../tmp/book/624c24de5f335/asset/plugins/highlight/index.js?v=1.0.0"></script>

    <script src="../tmp/book/624c24de5f335/asset/plugins/theme-classic/index.js?v=1.0.2"></script>

<script type="text/javascript">
    TopWrite.bootstrap();
</script>
</body>
</html>
