<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>11 - 数组和切片 - 万物联网服务平台</title>
    
    
    
    
</head>
<body>
<div id="root"></div>
<script type="application/payload+json">
{"id":"yWP4GW","summary":[{"id":"","title":"第0章 远程安装","articles":[]},{"id":"","title":"第1章 介绍和安装","articles":[{"title":"1 - 介绍和安装","ref":"\/docs\/golang_tutorial_01.md","path":"\/docs\/golang_tutorial_01.html","children":[]},{"title":"2 - Hello World ","ref":"\/docs\/golang_tutorial_02.md","path":"\/docs\/golang_tutorial_02.html","children":[]}]},{"id":"","title":"第2章 变量、类型和常量","articles":[{"title":"3 - 变量","ref":"\/docs\/golang_tutorial_03.md","path":"\/docs\/golang_tutorial_03.html","children":[]},{"title":"4 - 类型","ref":"\/docs\/golang_tutorial_04.md","path":"\/docs\/golang_tutorial_04.html","children":[]},{"title":"5 - 常量","ref":"\/docs\/golang_tutorial_05.md","path":"\/docs\/golang_tutorial_05.html","children":[]}]},{"id":"","title":"第3章 函数和包","articles":[{"title":"6 - 函数","ref":"\/docs\/golang_tutorial_06.md","path":"\/docs\/golang_tutorial_06.html","children":[]},{"title":"7 - 包","ref":"\/docs\/golang_tutorial_07.md","path":"\/docs\/golang_tutorial_07.html","children":[]}]},{"id":"","title":"第4章 条件和循环语句","articles":[{"title":"8 - if else 语句","ref":"\/docs\/golang_tutorial_08.md","path":"\/docs\/golang_tutorial_08.html","children":[]},{"title":"9 - 循环语句","ref":"\/docs\/golang_tutorial_09.md","path":"\/docs\/golang_tutorial_09.html","children":[]},{"title":"10 - switch语句","ref":"\/docs\/golang_tutorial_10.md","path":"\/docs\/golang_tutorial_10.html","children":[]}]},{"id":"","title":"第5章 数组、切片和变参函数","articles":[{"title":"11 - 数组和切片","ref":"\/docs\/golang_tutorial_11.md","path":"\/docs\/golang_tutorial_11.html","children":[]},{"title":"12 - 变 参函数","ref":"\/docs\/golang_tutorial_12.md","path":"\/docs\/golang_tutorial_12.html","children":[]}]},{"id":"","title":"第6章 更多的类型","articles":[{"title":"13 - Map","ref":"\/docs\/golang_tutorial_13.md","path":"\/docs\/golang_tutorial_13.html","children":[]},{"title":"14 - 字符串","ref":"\/docs\/golang_tutorial_14.md","path":"\/docs\/golang_tutorial_14.html","children":[]}]},{"id":"","title":"第7章 指针、结构体和方法","articles":[{"title":"15 - 指针","ref":"\/docs\/golang_tutorial_15.md","path":"\/docs\/golang_tutorial_15.html","children":[]},{"title":"16 -  结构体","ref":"\/docs\/golang_tutorial_16.md","path":"\/docs\/golang_tutorial_16.html","children":[]},{"title":"17 -  方法","ref":"\/docs\/golang_tutorial_17.md","path":"\/docs\/golang_tutorial_17.html","children":[]}]},{"id":"","title":"第8章 接口","articles":[]},{"id":"","title":"第9章 并发","articles":[{"title":" 21 - 协程","ref":"\/docs\/golang_tutorial_21.md","path":"\/docs\/golang_tutorial_21.html","children":[]}]},{"id":"","title":"第10章 面向对象编程","articles":[]},{"id":"","title":"第11章 延迟和错误处理","articles":[{"title":"35 - 读文件","ref":"\/docs\/golang_tutorial_35.md","path":"\/docs\/golang_tutorial_35.html","children":[]}]},{"id":"","title":"文档","articles":[{"title":"如何编写 Go代码","ref":"\/docs\/how_to_write_go_code.md","path":"\/docs\/how_to_write_go_code.html","children":[]}]}],"config":{"pluginsConfig":{"theme-default":{"auto_open":true,"navs":[{"title":"ThinkAPI","url":"https:\/\/docs.topthink.com\/think-api\/1835085"},{"title":"Tinywan","url":"https:\/\/market.topthink.com\/website"}]}},"title":"万物联网服务平台","plugins":["highlight","comment"],"theme":"classic"},"file":{"path":"\/docs\/golang_tutorial_11.html","content":"11 - 数组和切片  \n========================\n\n上一节：[第十篇 if else 语句](\/docs\/golang_tutorial_10.md)   \n下一节：[第十二篇 变参函数](\/docs\/golang_tutorial_12.md)  \n\n这是本Golang系列教程的第11篇。   \n\n## 数组  \n\n数组是类型相同的元素的集合。例如，整数 5, 8, 9, 79, 76 的集合就构成了一个数组。Go不允许在数组中混合使用不同类型的元素（比如整数和字符串）。  \n\n## 申明  \n\n数组的类型为` [n]T`，其中 `n` 表示数组中元素的个数，`T` 表示数组中元素的类型。元素的个数 `n`也是数组类型的一部分（我们将在稍后详细讨论）。  \n\n有很多声明数组的方式，让我们一个一个地介绍。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    var a [3]int \/\/int array with length 3\n    fmt.Println(a)\n}\n```\n\n`var a [3]int `声明了一个长度为 3 的整型数组。数组中的所有元素都被自动赋值为元素类型的 0 值。比如这里 a 是一个整型数组，因此 a 中的所有元素都被赋值为 0（即整型的 0 值）。运行上面的程序，输出为：`[0 0 0]`。\n\n数组的索引从 0 开始到 `length - 1` 结束。下面让我们给上面的数组赋一些值。\n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    var a [3]int \/\/int array with length 3\n    a[0] = 12 \/\/ array index starts at 0\n    a[1] = 78\n    a[2] = 50\n    fmt.Println(a)\n}\n```\n\n`a[0]`表示数组中的第一个元素。程序的输出为：`[12 78 50]`。\n\n（译者注：可以用下标运算符（`[]`）来访问数组中的元素，下标从 0 开始，例如 `a[0]` 表示数组 a 的第一个元素，`a[1] `表示数组 a 的第二元素，以此类推。）  \n\n可以利用**速记声明（shorthand declaration）**的方式来创建同样的数组：  \n\n```golang\npackage main \n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    a := [3]int{12, 78, 50} \/\/ shorthand declaration to create array\n    fmt.Println(a)\n}\n```\n\n上面的程序输出为：`[12 78 50]`。\n\n（译者注：这个例子给出了速记声明的方式：在数组类型后面加一对大括号（`{}`），在大括号里面写元素初始值列表，多个值用逗号分隔。）  \n\n在速记声明中，没有必要为数组中的每一个元素指定初始值。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    a := [3]int{12} \n    fmt.Println(a)\n}\n```\n\n上面程序的第 8 行：`a := [3]int{12} `声明了一个长度为 3 的数组，但是只提供了一个初值 12。剩下的两个元素被自动赋值为 0。程序 的输出为：`[12 0 0]`。  \n\n在声明数组时你可以忽略数组的长度并用` ... `代替，让编译器为你自动推导数组的长度。比如下面的程序：  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    a := [...]int{12, 78, 50} \/\/ ... makes the compiler determine the length\n    fmt.Println(a)\n}\n```\n\n上面已经提到，数组的长度是数组类型的一部分。因此 `[5]int` 和 `[25]int`是两个不同类型的数组。正是因为如此，一个数组不能动态改变长度。不要担心这个限制，因为切片（`slices`）可以弥补这个不足。  \n\n```golang\npackage main\n\nfunc main() {  \n    a := [3]int{5, 78, 8}\n    var b [5]int\n    b = a \/\/not possible since [3]int and [5]int are distinct types\n}\n```\n\n在上面程序的第 6 行，我们试图将一个` [3]int `类型的数组赋值给一个 `[5]int `类型的数组，这是不允许的。编译会报错：`main.go:6: cannot use a (type [3]int) as type [5]int in assignment。`  \n\n## 数组是值类型  \n\n在 Go 中数组是值类型而不是引用类型。这意味着当数组变量被赋值时，将会获得原数组（*译者注：也就是等号右面的数组*）的拷贝。新数组中元素的改变不会影响原数组中元素的值。  \n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {  \n    a := [...]string{\"USA\", \"China\", \"India\", \"Germany\", \"France\"}\n    b := a \/\/ a copy of a is assigned to b\n    b[0] = \"Singapore\"\n    fmt.Println(\"a is \", a)\n    fmt.Println(\"b is \", b) \n}\n```\n\n上面程序的第 7 行，将数组 a 的拷贝赋值给数组 b。第 8 行，b 的第一个元素被赋值为 `Singapore`。这将不会影响到原数组 a。程序的输出为：  \n\n```golang\na is [USA China India Germany France]  \nb is [Singapore China India Germany France]  \n```\n\n同样的，如果将数组作为参数传递给函数，仍然是值传递，在函数中对（作为参数传入的）数组的修改不会造成原数组的改变。  \n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc changeLocal(num [5]int) {  \n    num[0] = 55\n    fmt.Println(\"inside function \", num)\n\n}\nfunc main() {  \n    num := [...]int{5, 6, 7, 8, 8}\n    fmt.Println(\"before passing to function \", num)\n    changeLocal(num) \/\/num is passed by value\n    fmt.Println(\"after passing to function \", num)\n}\n```\n\n上面程序的第 13 行，数组 num 是通过值传递的方式传递给函数 `changeLocal` 的，因此该函数执行过程中不会造成 num 的改变。程序输出如下：  \n\n```golang\nbefore passing to function  [5 6 7 8 8]  \ninside function  [55 6 7 8 8]  \nafter passing to function  [5 6 7 8 8]  \n```\n\n## 数组的长度  \n\n内置函数 `len` 用于获取数组的长度：  \n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tarr := [...]float64{23.2,34.12,45.22,55.6}\n\tfmt.Println(\"length of a is  \",len(arr)); \/\/ print 4\n}\n```\n上面程序的输出为：`length of a is 4`。  \n\n## 使用 range 遍历数组  \n\n`for `循环可以用来遍历数组中的元素：  \n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {  \n    a := [...]float64{67.7, 89.8, 21, 78}\n    for i := 0; i < len(a); i++ { \/\/looping from 0 to the length of the array\n        fmt.Printf(\"%d th element of a is %.2f\\n\", i, a[i])\n    }\n}\n```\n上面的程序使用 for 循环遍历数组中的元素（索引从 0 到 len(a) - 1）。上面的程序输出如下：  \n\n```golang\n0 th element of a is 67.70  \n1 th element of a is 89.80  \n2 th element of a is 21.00  \n3 th element of a is 78.00  \n```\n\nGo 提供了一个更简单，更简洁的遍历数组的方法：使用 `range for`。range 返回数组的索引和索引对应的值。让我们用 range for 重写上面的程序（除此之外我们还计算了数组元素的总和）。  \n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {  \n    a := [...]float64{67.7, 89.8, 21, 78}\n    sum := float64(0)\n    for i, v := range a {\/\/range returns both the index and value\n        fmt.Printf(\"%d the element of a is %.2f\\n\", i, v)\n        sum += v\n    }\n    fmt.Println(\"\\nsum of all elements of a\",sum)\n}  \n```\n\n上面的程序中，第 8 行 for i, v := range a 是 range 形式的 for 循环。range 将返回数组的索引和相对应的元素。我们打印这些值并计算数组 a 中所有元素的总和。程序的输出如下：   \n\n```golang\n0 the element of a is 67.70  \n1 the element of a is 89.80  \n2 the element of a is 21.00  \n3 the element of a is 78.00\n\nsum of all elements of a 256.5 \n```\n\n如果你只想访问数组元素而不需要访问数组索引，则可以通过空标识符来代替索引变量：  \n\n```golang\nfor _, v := range a { \/\/ignores index  \n}\n```\n\n上面的代码忽略了索引。同样的，也可以忽略值。  \n\n## 多维数组  \n\n目前为止我们创建的数组都是一维的。也可以创建多维数组。   \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc printarray(a [3][2]string) {  \n    for _, v1 := range a {\n        for _, v2 := range v1 {\n            fmt.Printf(\"%s \", v2)\n        }\n        fmt.Printf(\"\\n\")\n    }\n}\n\nfunc main() {  \n    a := [3][2]string{\n        {\"lion\", \"tiger\"},\n        {\"cat\", \"dog\"},\n        {\"pigeon\", \"peacock\"}, \/\/this comma is necessary. The compiler will complain if you omit this comma\n    }\n    printarray(a)\n    var b [3][2]string\n    b[0][0] = \"apple\"\n    b[0][1] = \"samsung\"\n    b[1][0] = \"microsoft\"\n    b[1][1] = \"google\"\n    b[2][0] = \"AT&T\"\n    b[2][1] = \"T-Mobile\"\n    fmt.Printf(\"\\n\")\n    printarray(b)\n}\n```\n\n上面的程序中，第 17 行利用速记声明创建了一个二维数组 a。第 20 行的逗号是必须的，这是因为词法分析器会根据一些简单的规则自动插入分号。如果你想了解更多，请阅读：https:\/\/golang.org\/doc\/effective_go.html#semicolons 。  \n\n在第 23 行声明了另一个二维数组 b，并通过索引的方式给数组 b 中的每一个元素赋值。这是初始化二维数组的另一种方式。  \n\n第 7 行声明的函数 printarray 通过两个嵌套的 range for 打印二维数组的内容。上面程序的输出为：  \n\n```golang\nlion tiger  \ncat dog  \npigeon peacock \n\napple samsung  \nmicrosoft google  \nAT&T T-Mobile \n```\n\n以上就是对数组的介绍。尽管数组看起来足够灵活，但是数组的长度是固定的，没办法动态增加数组的长度。而切片却没有这个限制，实际上在 Go 中，切片比数组更为常见。  \n\n## 切片  \n\n切片（slice）是建立在数组之上的更方便，更灵活，更强大的数据结构。切片并不存储任何元素而只是对现有数组的引用。  \n\n## 创建切片  \n\n元素类型为 `T `的切片表示为： `[]T`。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    a := [5]int{76, 77, 78, 79, 80}\n    var b []int = a[1:4] \/\/creates a slice from a[1] to a[3]\n    fmt.Println(b)\n}\n```\n\n通过 `a[start:end] `这样的语法创建了一个从` a[start]` 到 `a[end -1]` 的切片。在上面的程序中，第 9 行` a[1:4]` 创建了一个从 `a[1]` 到 `a[3]` 的切片。因此 b 的值为：`[77 78 79]`。  \n\n下面是创建切片的另一种方式：  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    c := []int{6, 7, 8} \/\/creates and array and returns a slice reference\n    fmt.Println(c)\n}\n```\n\n在上面的程序中，第 9 行 `c := []int{6, 7, 8} `创建了一个长度为 3 的 int 数组，并返回一个切片给 c。  \n\n## 修改切片  \n\n切片本身不包含任何数据。它仅仅是底层数组的一个上层表示。对切片进行的任何修改都将反映在底层数组中。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    darr := [...]int{57, 89, 90, 82, 100, 78, 67, 69, 59}\n    dslice := darr[2:5]\n    fmt.Println(\"array before\",darr)\n    for i := range dslice {\n        dslice[i]++\n    }\n    fmt.Println(\"array after\",darr) \n}\n```\n\n上面程序的第 9 行，我们创建了一个从 darr[2] 到 darr[5] 的切片 dslice。for 循环将这些元素值加 1。执行完 for 语句之后打印原数组的值，我们可以看到原数组的值被改变了。程序输出如下：  \n\n```golang\narray before [57 89 90 82 100 78 67 69 59]  \narray after [57 89 91 83 101 78 67 69 59]  \n```\n\n当若干个切片共享同一个底层数组时，对每一个切片的修改都会反映在底层数组中。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    numa := [3]int{78, 79 ,80}\n    nums1 := numa[:] \/\/creates a slice which contains all elements of the array\n    nums2 := numa[:]\n    fmt.Println(\"array before change 1\",numa)\n    nums1[0] = 100\n    fmt.Println(\"array after modification to slice nums1\", numa)\n    nums2[1] = 101\n    fmt.Println(\"array after modification to slice nums2\", numa)\n}\n```\n\n可以看到，在第 9 行，` numa[:] `中缺少了开始和结束的索引值，这种情况下开始和结束的索引值默认为 `0` 和` len(numa)`。这里 `nums1` 和 `nums2` 共享了同一个数组。程序的输出为：  \n\n```golang\narray before change 1 [78 79 80]  \narray after modification to slice nums1 [100 79 80]  \narray after modification to slice nums2 [100 101 80] \n```\n\n从输出结果可以看出，当多个切片共享同一个数组时，对每一个切片的修改都将会反映到这个数组中。  \n\n## 切片的长度和容量  \n\n切片的长度是指切片中元素的个数。切片的容量是指从切片的起始元素开始到其底层数组中的最后一个元素的个数。  \n\n*（译者注：使用内置函数 cap 返回切片的容量。）*  \n\n让我们写一些代码来更好地理解这一点。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    fruitarray := [...]string{\"apple\", \"orange\", \"grape\", \"mango\", \"water melon\", \"pine apple\", \"chikoo\"}\n    fruitslice := fruitarray[1:3]\n    fmt.Printf(\"length of slice %d capacity %d\", len(fruitslice), cap(fruitslice)) \/\/length of is 2 and capacity is 6\n}\n```\n\n在上面的程序中，创建了一个以 fruitarray 为底层数组，索引从 1 到 3 的切片 `fruitslice`。因此 fruitslice 长度为 2。\n\n`fruitarray` 的长度是 7。`fruiteslice` 是从 `fruitarray` 的索引 1 开始的。因此 `fruiteslice` 的容量是从 `fruitarray` 的第 1 个元素开始算起的数组中的元素个数，这个值是 6。因此 `fruitslice` 的容量是 6。程序的输出为：`length of slice 2 capacity 6 `  \n\n切片的长度可以动态的改变（最大为其容量）。任何超出最大容量的操作都会发生运行时错误。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    fruitarray := [...]string{\"apple\", \"orange\", \"grape\", \"mango\", \"water melon\", \"pine apple\", \"chikoo\"}\n    fruitslice := fruitarray[1:3]\n    fmt.Printf(\"length of slice %d capacity %d\\n\", len(fruitslice), cap(fruitslice)) \/\/length of is 2 and capacity is 6\n    fruitslice = fruitslice[:cap(fruitslice)] \/\/re-slicing furitslice till its capacity\n    fmt.Println(\"After re-slicing length is\",len(fruitslice), \"and capacity is\",cap(fruitslice))\n}\n```\n\n在上面的程序中， 第 11 行修改 fruitslice 的长度为它的容量。上面的程序输出如下：  \n\n```golang\nlength of slice 2 capacity 6  \nAfter re-slicing length is 6 and capacity is 6  \n```\n\n## 用 make 创建切片  \n\n内置函数` func make([]T, len, cap) []T` 可以用来创建切片，该函数接受**长度**和**容量**作为参数，返回切片。容量是可选的，默认与长度相同。使用 make 函数将会创建一个数组并返回它的切片。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    i := make([]int, 5, 5)\n    fmt.Println(i)\n}\n```\n\n用 make 创建的切片的元素值默认为 0 值。上面的程序输出为：`[0 0 0 0 0]`。  \n\n##  追加元素到切片  \n\n我们已经知道数组是固定长度的，它们的长度不能动态增加。而切片是动态的，可以使用内置函数 append 添加元素到切片。append 的函数原型为：`append(s []T, x ...T) []T`。  \n\n`x …T` 表示 append 函数可以接受的参数个数是可变的。这种函数叫做变参函数。  \n\n你可能会问一个问题：如果切片是建立在数组之上的，而数组本身不能改变长度，那么切片是如何动态改变长度的呢？实际发生的情况是，当新元素通过调用 append 函数追加到切片末尾时，如果超出了容量，append 内部会创建一个新的数组。并将原有数组的元素被拷贝给这个新的数组，最后返回建立在这个新数组上的切片。这个新切片的容量是旧切片的二倍（译者注：当超出切片的容量时，append 将会在其内部创建新的数组，该数组的大小是原切片容量的 2 倍。最后 append 返回这个数组的全切片，即从 0 到 length - 1 的切片）。下面的程序使事情变得明朗：  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    cars := []string{\"Ferrari\", \"Honda\", \"Ford\"}\n    fmt.Println(\"cars:\", cars, \"has old length\", len(cars), \"and capacity\", cap(cars)) \/\/capacity of cars is 3\n    cars = append(cars, \"Toyota\")\n    fmt.Println(\"cars:\", cars, \"has new length\", len(cars), \"and capacity\", cap(cars)) \/\/capacity of cars is doubled to 6\n}\n```\n\n在上面的程序中，cars 的容量开始时为 3。在第 10 行我们追加了一个新的元素给 `cars`，并将 `append(cars, \"Toyota\") `的返回值重新复制给 cars。现在 cars 的容量翻倍，变为 6。上面的程序输出为：  \n\n```golang\ncars: [Ferrari Honda Ford] has old length 3 and capacity 3  \ncars: [Ferrari Honda Ford Toyota] has new length 4 and capacity 6  \n```\n\n切片的 0 值为 `nil`。一个 `nil` 切片的长度和容量都为 0。可以利用 `append` 函数给一个 `nil` 切片追加值。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    var names []string \/\/zero value of a slice is nil\n    if names == nil {\n        fmt.Println(\"slice is nil going to append\")\n        names = append(names, \"John\", \"Sebastian\", \"Vinay\")\n        fmt.Println(\"names contents:\",names)\n    }\n}\n```\n\n在上面的程序中 `names` 为 `nil`，并且我们把 3 个字符串追加给 `names`。程序的输出为：  \n\n```golang\nslice is nil going to append  \nnames contents: [John Sebastian Vinay]  \n```\n\n可以使用 `...` 操作符将一个切片追加到另一个切片末尾：  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    veggies := []string{\"potatoes\",\"tomatoes\",\"brinjal\"}\n    fruits := []string{\"oranges\",\"apples\"}\n    food := append(veggies, fruits...)\n    fmt.Println(\"food:\",food)\n}\n```\n上面的程序中，在第10行将 `fruits` 追加到 `veggies` 并赋值给 `food`。`...`操作符用来展开切片。程序的输出为：`food: [potatoes tomatoes brinjal oranges apples]`。  \n\n## 切片作为函数参数  \n\n可以认为切片在内部表示为如下的结构体：  \n\n```golang\ntype slice struct {  \n    Length        int\n    Capacity      int\n    ZerothElement *byte\n}\n```\n\n可以看到切片包含长度、容量、以及一个指向首元素的指针。当将一个切片作为参数传递给一个函数时，虽然是值传递，但是指针始终指向同一个数组。因此将切片作为参数传给函数时，函数对该切片的修改在函数外部也可以看到。让我们写一个程序来验证这一点。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc subtactOne(numbers []int) {  \n    for i := range numbers {\n        numbers[i] -= 2\n    }\n\n}\nfunc main() {\n\n    nos := []int{8, 7, 6}\n    fmt.Println(\"slice before function call\", nos)\n    subtactOne(nos)                               \/\/function modifies the slice\n    fmt.Println(\"slice after function call\", nos) \/\/modifications are visible outside\n\n}\n```\n\n在上面的程序中，第 17 行将切片中的每个元素的值减2。在函数调用之后打印切片的的内容，发现切片内容发生了改变。你可以回想一下，这不同于一个数组，对函数内部的数组所做的更改在函数外不可见。上面的程序输出如下：\n\n```golang\narray before function call [8 7 6]  \narray after function call [6 5 4]  \n```\n\n##  多维切片  \n\n同数组一样，切片也可以有多个维度。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\n\nfunc main() {  \n     pls := [][]string {\n            {\"C\", \"C++\"},\n            {\"JavaScript\"},\n            {\"Go\", \"Rust\"},\n            }\n    for _, v1 := range pls {\n        for _, v2 := range v1 {\n            fmt.Printf(\"%s \", v2)\n        }\n        fmt.Printf(\"\\n\")\n    }\n}\n```\n\n上面程序的输出如下：\n\n```golang\nC C++  \nJavaScript  \nGo Rust  \n```\n\n## 内存优化  \n\n切片保留对底层数组的引用。只要切片存在于内存中，数组就不能被垃圾回收。这在内存管理方便可能是值得关注的。假设我们有一个非常大的数组，而我们只需要处理它的一小部分，为此我们创建这个数组的一个切片，并处理这个切片。这里要注意的事情是，数组仍然存在于内存中，因为切片正在引用它。  \n\n解决该问题的一个方法是使用 copy 函数 `func copy(dst, src []T) int `来创建该切片的一个拷贝。这样我们就可以使用这个新的切片，原来的数组可以被垃圾回收。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc countries() []string {  \n    countries := []string{\"USA\", \"Singapore\", \"Germany\", \"India\", \"Australia\"}\n    neededCountries := countries[:len(countries)-2]\n    countriesCpy := make([]string, len(neededCountries))\n    copy(countriesCpy, neededCountries) \/\/copies neededCountries to countriesCpy\n    return countriesCpy\n}\nfunc main() {  \n    countriesNeeded := countries()\n    fmt.Println(countriesNeeded)\n}\n```\n\n在上面程序中，第 9 行 `neededCountries := countries[:len(countries)-2] `创建一个底层数组为 `countries` 并排除最后两个元素的切片。第 11 行将 `neededCountries` 拷贝到 `countriesCpy` 并在下一行返回 `countriesCpy`。现在数组 `countries` 可以被垃圾回收，因为 `neededCountries` 不再被引用。  \n\n我（原文作者）已经将我们讨论的所有概念汇总到一个程序中，你可以从 [github](https:\/\/github.com\/golangbot\/arraysandslices) 下载。  \n\n## 扩展  \n\n####  数组\n[深入解析 Go 中 Slice 底层实现](https:\/\/halfrost.com\/go_slice\/)\n###### 创建（定义）数组\n数组在Go中是值类型，而不是引用（其他语言的数组则是引用类型）\nPS：切片（slice）是一个引用类型\n数组不是统一的类型，大小不同的数组是不可以比较的\n不同数组类型是不可以比较的\n```golang\nvar a[2]int\nvar b[3]string\n\n\/\/ 提前知道数组中的值\nvar a[2]int{11,22}\nvar a[20]int{19:11} \/\/ 索引值为19的元素赋值为 11 ，其他的默认为 0\n\n\/\/ 不指定数组的长度 ...\nvar c = [...]int{11,22,33,44}\nvar d = [...]int{19:90} \/\/ 尽可能的满足索引值得数组\n```\n\n###### 指向数组的指针和指向指针的数组\n\n```golang\n\/\/定义数组a\na := [...]int{19:100}\n\n\/\/ 指向数组的指针\nvar p *[20]int = &a  \/\/长度为20的int型数组，这里的数组长度`20`必须和a数组长度相等\nfmt.Println(p) \/\/以上表示取这样一个数组的地址 \n\/\/ 打印结果：&[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 19]\n\n\/\/指向指针的数组\nx , y  := 1, 2\npp := [...]*int{&x,&y} \/\/ 指向int型的指针，保存的元素是指向int型的指针。输出x,y的地址：\nfmt.Println(\"pp is \",pp)  \/\/ 打印结果：pp is  [0xc420012128 0xc420012130]\n```\n###### new 创建一个数组\n\n```golang\n ppp := new([10]int)\nfmt.Println(\"----ppp-------\",ppp); \/\/输出结果：`&[0 0 0 0 0 0 0 0 0 0]` \n\/\/以上为指向数组的指针\n```\n\n###### 两种方式修改数组赋值\n\n```golang\n\/\/ 第一种方式\nn := [10]int{}\nn[1] = 10\nfmt.Println(\"-----1------\",n)  \/\/ 输出：`[0 10 0 0 0 0 0 0 0 0]`\n\n\/\/ 第二种方式\nm := new([10]int)\nm[1] = 20\nfmt.Println(\"-----2------\",m)  \/\/ 输出：`&[0 20 0 0 0 0 0 0 0 0]`\n```\n\n###### 多维数组\n\n```golang\narr := [2][3]int{\n                {1, 2, 3},\n                {4, 5, 6}} \/\/最外面的`}`不可以换行的，否则报错：`syntax error`\nfmt.Println(\"-----\",arr)\n```\n\n#### 冒泡排序\n\n###### 第一种写法\n```golang\nfunc main(){\n        a :=[...]int64{12,23,293,34,128,132}\n        fmt.Println(a)\n        num := len(a)\n        for i := 0; i<num; i++ {\n                for j := i+1; j<num; j++ {\n                        if a[i]<a[j] {\n                                tmp := a[i]\n                                a[i] = a[j]\n                                a[j] = tmp\n                        }\n                } \n        }\n        fmt.Println(a)\n}\n```\n> 从大到小排序\n\n###### 第二种写法\n\n```golang\nfunc main(){\n        a :=[...]int64{12,23,293,34,128,132}\n        fmt.Println(a)\n        num := len(a)\n        for i := 0; i<num; i++ {\n                for j := i+1; j<num; j++ {\n                        if a[i]<a[j] {\n                                a[i],a[j] = a[j],a[i]\n                        }\n                } \n        }\n        fmt.Println(a)\n}\n```  \n\n#### 切片  \n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\ta := [10]int{1,2,3,4,5,6,7,8,9}\n\tvar s1  []int\n\tfmt.Println(s1) \/\/ 输出：[]\n\n\t\/\/ 只取一个元素\n\ts2 := a[5]\n\tfmt.Println(s2) \/\/ 输出：6\n\n\t\/\/ 只取前5个元素\n\ts3 := a[:5]\n\tfmt.Println(s3) \/\/ 输出：[1 2 3 4 5]\n\n\t\/\/ 只取后5个元素\n\ts4 := a[5:]\n\tfmt.Println(s4) \/\/ 输出：[6 7 8 9 0]\n\n\t\/\/ 截取某一段元素，不包括最后一个\n\ts5 := a[5:8]\n\tfmt.Println(s5) \/\/ 输出：[6 7 8]\n\n\t\/\/ 使用make创建一个切片\n\ts6 := make([]int, 3, 10) \/\/  func make([]T, len, cap) []T 可以用来创建切片\n\tfmt.Println(len(s6),cap(s6));\n\n\ts7 := []byte{'a','b','c','d','e','f','g','h','i','j','k'} \/\/ 切片底层对应的数组\n\n\tslice_a := s7[2:5]\n\tfmt.Println(slice_a) \/\/\t输出的assica码 值 [99 100 101]\n\tfmt.Println(string(slice_a)) \/\/ 格式化为字符串输出\n\tfmt.Println(len(slice_a),cap(slice_a))\n\n\tslice_b := s7[3:5]\n\tfmt.Println(string(slice_b)) \/\/ 格式化为字符串输出\n\n\t\/\/ append 函数使用\n\ts8 := make([]int, 3, 6) \/\/ 3个元素，容量为6的切片\n\tfmt.Printf(\"%p\\n\", s8)  \/\/ 打印内存地址：0xc042074030\n\ts8 = append(s8, 12, 48)\n\tfmt.Printf(\"%v %p\", s8, s8) \/\/ 格式化打印值和内存地址：[0 0 0 12 48] 0xc042074030\n\n\t\/\/ 追加的元素如果没有超多切片容量，则切片的地址是不变的，否则内存地址会变\n\ts8 = append(s8, 66, 88)\n\tfmt.Printf(\"%v %p\\n\", s8, s8) \/\/ [0 0 0 12 48 66 88] 0xc042048060\n\n\t\/\/ copy 使用\n\ts9 := []int{1,2,3,4,5,6,7}\n\ts10 := []int{33,44,55}\n\tcopy(s9,s10) \/\/ copy(拷贝，被拷贝)\n\tfmt.Println(s9) \/\/[33 44 55 4 5 6 7]\n\n\tcopy(s10,s9) \n\tfmt.Println(s10) \/\/ [33 44 55]\n\n\tcopy(s9[2:4],s10[0:2]) \n\tfmt.Println(s9) \/\/ [1 2 33 44 5 6 7]\n\n\ts11 := s7[:]\n\tfmt.Println(s11) \/\/ copy一个数组的所有\n}\n```  \n\n希望你喜欢阅读。请留下宝贵的意见和反馈:)  \n","meta":{"mtime":""}}}
</script>

    <script src="../tmp/book/624c24de5f335/asset/lodash/lodash.min.js?v=4.17.21"></script>

    <script src="../tmp/book/624c24de5f335/asset/react/react.production.min.js?v=17.0.2"></script>

    <script src="../tmp/book/624c24de5f335/asset/react-dom/react-dom.production.min.js?v=17.0.2"></script>

    <script src="../tmp/book/624c24de5f335/asset/reader/index.js?v=1.0.24"></script>

    <script src="../tmp/book/624c24de5f335/asset/plugins/comment/index.js?v=0.0.1"></script>

    <script src="../tmp/book/624c24de5f335/asset/plugins/highlight/index.js?v=1.0.0"></script>

    <script src="../tmp/book/624c24de5f335/asset/plugins/theme-classic/index.js?v=1.0.2"></script>

<script type="text/javascript">
    TopWrite.bootstrap();
</script>
</body>
</html>
