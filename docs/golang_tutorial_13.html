<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>13 - Map - 万物联网服务平台</title>
    
    
    
    
</head>
<body>
<div id="root"></div>
<script type="application/payload+json">
{"id":"yWP4GW","summary":[{"id":"","title":"第0章 远程安装","articles":[]},{"id":"","title":"第1章 介绍和安装","articles":[{"title":"1 - 介绍和安装","ref":"\/docs\/golang_tutorial_01.md","path":"\/docs\/golang_tutorial_01.html","children":[]},{"title":"2 - Hello World ","ref":"\/docs\/golang_tutorial_02.md","path":"\/docs\/golang_tutorial_02.html","children":[]}]},{"id":"","title":"第2章 变量、类型和常量","articles":[{"title":"3 - 变量","ref":"\/docs\/golang_tutorial_03.md","path":"\/docs\/golang_tutorial_03.html","children":[]},{"title":"4 - 类型","ref":"\/docs\/golang_tutorial_04.md","path":"\/docs\/golang_tutorial_04.html","children":[]},{"title":"5 - 常量","ref":"\/docs\/golang_tutorial_05.md","path":"\/docs\/golang_tutorial_05.html","children":[]}]},{"id":"","title":"第3章 函数和包","articles":[{"title":"6 - 函数","ref":"\/docs\/golang_tutorial_06.md","path":"\/docs\/golang_tutorial_06.html","children":[]},{"title":"7 - 包","ref":"\/docs\/golang_tutorial_07.md","path":"\/docs\/golang_tutorial_07.html","children":[]}]},{"id":"","title":"第4章 条件和循环语句","articles":[{"title":"8 - if else 语句","ref":"\/docs\/golang_tutorial_08.md","path":"\/docs\/golang_tutorial_08.html","children":[]},{"title":"9 - 循环语句","ref":"\/docs\/golang_tutorial_09.md","path":"\/docs\/golang_tutorial_09.html","children":[]},{"title":"10 - switch语句","ref":"\/docs\/golang_tutorial_10.md","path":"\/docs\/golang_tutorial_10.html","children":[]}]},{"id":"","title":"第5章 数组、切片和变参函数","articles":[{"title":"11 - 数组和切片","ref":"\/docs\/golang_tutorial_11.md","path":"\/docs\/golang_tutorial_11.html","children":[]},{"title":"12 - 变 参函数","ref":"\/docs\/golang_tutorial_12.md","path":"\/docs\/golang_tutorial_12.html","children":[]}]},{"id":"","title":"第6章 更多的类型","articles":[{"title":"13 - Map","ref":"\/docs\/golang_tutorial_13.md","path":"\/docs\/golang_tutorial_13.html","children":[]},{"title":"14 - 字符串","ref":"\/docs\/golang_tutorial_14.md","path":"\/docs\/golang_tutorial_14.html","children":[]}]},{"id":"","title":"第7章 指针、结构体和方法","articles":[{"title":"15 - 指针","ref":"\/docs\/golang_tutorial_15.md","path":"\/docs\/golang_tutorial_15.html","children":[]},{"title":"16 -  结构体","ref":"\/docs\/golang_tutorial_16.md","path":"\/docs\/golang_tutorial_16.html","children":[]},{"title":"17 -  方法","ref":"\/docs\/golang_tutorial_17.md","path":"\/docs\/golang_tutorial_17.html","children":[]}]},{"id":"","title":"第8章 接口","articles":[]},{"id":"","title":"第9章 并发","articles":[{"title":" 21 - 协程","ref":"\/docs\/golang_tutorial_21.md","path":"\/docs\/golang_tutorial_21.html","children":[]}]},{"id":"","title":"第10章 面向对象编程","articles":[]},{"id":"","title":"第11章 延迟和错误处理","articles":[{"title":"35 - 读文件","ref":"\/docs\/golang_tutorial_35.md","path":"\/docs\/golang_tutorial_35.html","children":[]}]},{"id":"","title":"文档","articles":[{"title":"如何编写 Go代码","ref":"\/docs\/how_to_write_go_code.md","path":"\/docs\/how_to_write_go_code.html","children":[]}]}],"config":{"pluginsConfig":{"theme-default":{"auto_open":true,"navs":[{"title":"ThinkAPI","url":"https:\/\/docs.topthink.com\/think-api\/1835085"},{"title":"Tinywan","url":"https:\/\/market.topthink.com\/website"}]}},"title":"万物联网服务平台","plugins":["highlight","comment"],"theme":"classic"},"file":{"path":"\/docs\/golang_tutorial_13.html","content":"13 - Map 集合  \n========================\n\n上一节：[第十篇 if else 语句](\/docs\/golang_tutorial_10.md)   \n下一节：[第十二篇 包](\/docs\/golang_tutorial_12.md)  \n\n这是本Golang系列教程的第13篇。   \n\n## 什么是 map？  \n\nMap 是 Go 中的内置类型，它将键与值绑定到一起。可以通过键获取相应的值。  \n\n## 如何创建 map？  \n\n可以通过将键和值的类型传递给内置函数 `make` 来创建一个 `map`。语法为：`make(map[KeyType]ValueType)`。（译者注：`map` 的类型表示为 `map[KeyType]ValueType`）例如：   \n\n```golang\npersonSalary := make(map[string]int) \n```\n\n上面的代码创建了一个名为 `personSalary` 的 map。其中键的类型为 string，值的类型为 int。  \n\n**map 的 0 值为 `nil`。试图给一个 nil map 添加元素给会导致运行时错误。因此 map 必须通过 make 来初始化** （译者注：也可以使用速记声明来创建 map，见下文）。    \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    var personSalary map[string]int\n    if personSalary == nil {\n        fmt.Println(\"map is nil. Going to make one.\")\n        personSalary = make(map[string]int)\n    }\n}\n```\n\n上面的程序中，`personSalary` 为 `nil`，因此使用 make 初始化它。程序的输出为：`map is nil. Going to make one`.   \n\n## 向 map 中插入元素  \n\n插入元素给 map 的语法与数组相似。下面的代码插入一些新的元素给 `map personSalary`。  \n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    personSalary := make(map[string]int)\n    personSalary[\"steve\"] = 12000\n    personSalary[\"jamie\"] = 15000\n    personSalary[\"mike\"] = 9000\n    fmt.Println(\"personSalary map contents:\", personSalary)\n}\n```\n\n上面的程序输出：`personSalary map contents: map[steve:12000 jamie:15000 mike:9000]`。  \n\n也可以在声明时初始化一个数组：  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    personSalary := map[string]int {\n        \"steve\": 12000,\n        \"jamie\": 15000,\n    }\n    personSalary[\"mike\"] = 9000\n    fmt.Println(\"personSalary map contents:\", personSalary)\n}\n```\n\n上面的程序在声明 personSalary 的同时向其中插入了两个元素。接着插入了一个以 \"mike\" 为键的元素。程序的输出为：  \n\n```golang\npersonSalary map contents: map[steve:12000 jamie:15000 mike:9000] \n```\n\n`string` 并不是可以作为键的唯一类型，其他所有可以比较的类型，比如，布尔类型，整型，浮点型，复数类型都可以作为键。如果你想了解更多关于可比较类型的话，请参阅：http:\/\/golang.org\/ref\/spec#Comparison_operators  \n\n## 访问 map 中的元素  \n\n现在我们已经添加了一些元素给 map，现在让我们学习如何从 map 中提取它们。根据键获取值的语法为：`map[key]`，例如：  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    personSalary := map[string]int{\n        \"steve\": 12000,\n        \"jamie\": 15000,\n    }\n    personSalary[\"mike\"] = 9000\n    employee := \"jamie\"\n    fmt.Println(\"Salary of\", employee, \"is\", personSalary[employee])\n}\n```\n\n上面的程序非常简单。员工 `jamie` 的工资被取出并打印。程序的输出为：`Salary of jamie is 15000`。  \n\n如果一个键不存在会发生什么？`map` 会返回值类型的 `0 `值。比如如果访问了 `personSalary` 中的不存在的键，那么将返回 `int` 的 0 值，也就是 0。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    personSalary := map[string]int{\n        \"steve\": 12000,\n        \"jamie\": 15000,\n    }\n    personSalary[\"mike\"] = 9000\n    employee := \"jamie\"\n    fmt.Println(\"Salary of\", employee, \"is\", personSalary[employee])\n    fmt.Println(\"Salary of joe is\", personSalary[\"joe\"])\n}\n```\n\n上面的程序输出为:  \n\n```golang\nSalary of jamie is 15000  \nSalary of joe is 0  \n```\n\n上面的程序返回 `joe` 的工资为` 0`。我们没有得到任何运行时错误说明键 joe 在 `personSalary` 中不存在。\n\n我们如何检测一个键是否存在于一个 map 中呢？可以使用下面的语法：\n\n```golang\nvalue, ok := map[key]  \n```\n\n上面的语法可以检测一个特定的键是否存在于 map 中。如果 `ok` 是 `true`，则键存在，value 被赋值为对应的值。如果 `ok` 为 `false`，则表示键不存在。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    personSalary := map[string]int{\n        \"steve\": 12000,\n        \"jamie\": 15000,\n    }\n    personSalary[\"mike\"] = 9000\n    newEmp := \"joe\"\n    value, ok := personSalary[newEmp]\n    if ok == true {\n        fmt.Println(\"Salary of\", newEmp, \"is\", value)\n    } else {\n        fmt.Println(newEmp,\"not found\")\n    }\n\n}\n```\n\n在上面的程序中，第 15 行，`ok` 应该为 `false` ，因为 `joe` 不存在。因此程序的输出为：\n\n```golang\njoe not found\n```\n\nrange for 可用于遍历 map 中所有的元素（译者注：这里 range 操作符会返回 map 的键和值）。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    personSalary := map[string]int{\n        \"steve\": 12000,\n        \"jamie\": 15000,\n    }\n    personSalary[\"mike\"] = 9000\n    fmt.Println(\"All items of a map\")\n    for key, value := range personSalary {\n        fmt.Printf(\"personSalary[%s] = %d\\n\", key, value)\n    }\n}\n```\n\n上面的程序输出如下：  \n\n```golang\nAll items of a map  \npersonSalary[mike] = 9000  \npersonSalary[steve] = 12000  \npersonSalary[jamie] = 15000\n```\n\n值得注意的是，因为 map 是无序的，因此对于程序的每次执行，不能保证使用 range for 遍历 map 的顺序总是一致的。  \n\n## 删除元素  \n\n`delete(map, key) `用于删除 map 中的 key。delete 函数没有返回值。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    personSalary := map[string]int{\n        \"steve\": 12000,\n        \"jamie\": 15000,\n    }\n    personSalary[\"mike\"] = 9000\n    fmt.Println(\"map before deletion\", personSalary)\n    delete(personSalary, \"steve\")\n    fmt.Println(\"map after deletion\", personSalary)\n\n}\n```\n\n上面的程序删除以 `steve` 为键的元素。程序输出为：  \n\n```golang\nmap before deletion map[steve:12000 jamie:15000 mike:9000]  \nmap after deletion map[mike:9000 jamie:15000] \n```\n\n## map 的大小  \n\n用内置函数 `len` 获取 map 的大小：  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    personSalary := map[string]int{\n        \"steve\": 12000,\n        \"jamie\": 15000,\n    }\n    personSalary[\"mike\"] = 9000\n    fmt.Println(\"length is\", len(personSalary))\n\n}\n```\n\n上面程序中，`len(personSalary) `获取 `personSalary` 的大小。上面的程序输出：`length is 3`。  \n\n##  map 是引用类型  \n\n与切片一样，map 是引用类型。当一个 map 赋值给一个新的变量，它们都指向同一个内部数据结构。因此改变其中一个也会反映到另一个：  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    personSalary := map[string]int{\n        \"steve\": 12000,\n        \"jamie\": 15000,\n    }\n    personSalary[\"mike\"] = 9000\n    fmt.Println(\"Original person salary\", personSalary)\n    newPersonSalary := personSalary\n    newPersonSalary[\"mike\"] = 18000\n    fmt.Println(\"Person salary changed\", personSalary)\n}\n```\n\n上面的程序中，第 14 行，`personSalary` 赋值给 `newPersonSalary`。下一行，将 `newPersonSalary` 中 `mike` 的工资改为 `18000`。那么在 `personSalary` 中 `mike` 的工资也将变为 `18000`。程序的输出如下：  \n\n```golang\nOriginal person salary map[steve:12000 jamie:15000 mike:9000]  \nPerson salary changed map[jamie:15000 mike:18000 steve:12000] \n```\n\n将 map 作为参数传递给函数也是一样的。在函数中对 map 的任何修改都会影响在调用函数中看到。  \n\n##  比较 map  \n\nmap 不能通过 `== `操作符比较是否相等。`== `操作符只能用来检测 map 是否为 nil。  \n\n```golang\npackage main\n\nfunc main() {  \n    map1 := map[string]int{\n        \"one\": 1,\n        \"two\": 2,\n    }\n\n    map2 := map1\n\n    if map1 == map2 {\n    }\n}\n```\n\n上面的程序将会报错：`invalid operation: map1 == map2 (map can only be compared to nil)`。  \n\n比较两个 map 是否相等的方式是一一比较它们的元素是否相等。我会鼓励你为此编写一个程序，使其工作：）  \n\n我（原文作者）已经将我们讨论的所有概念汇总到一个程序中，你可以从 [github](https:\/\/github.com\/golangbot\/arraysandslices) 下载。  \n\n希望你喜欢阅读。请留下宝贵的意见和反馈:)   \n\n## 以下为扩展知识  \n\n[Go编程基础视频教程笔记](https:\/\/study.163.com\/course\/courseLearn.htm?courseId=306002#\/learn\/video?lessonId=421019&courseId=306002)  \n\n```golang\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\nfunc main(){\n\t\/\/ 方式一 \n\tvar m map[int]string \/\/ 声明一个map，此时的 map == nil\n\tfmt.Println(m)\n\tm = map[int]string{} \/\/ 初始化一个map，此时的 map != nil，是map[]\n\tfmt.Println(m)\n\t\/\/ 以上两种的区别在于有没有被初始化容量  \n\n\t\/\/ 方式二\n\tvar m2 map[int]string = map[int]string{}\n\tfmt.Println(m2)\n\n\t\/\/ 方式三\n\tm3 := map[int]string{}\n\tfmt.Println(m3)\n\t\n\t\/\/ 方式四\n\tm4 := map[string]string{\n        \"name\":\"Tinywan\",\n        \"school\":\"BAT_UN\"\n\t}\n\tfmt.Println(m4)\n\tm5 := make(map[string][string])\n\tm5[\"name\"] = \"Linux\"\n\tm5[\"school\"] = \"Unix\"\n\t\/\/ 注意：m4和m5两种初始化的方式等价\n\t\n\t\/\/ 设置、获取、删除\n\tm3[1] = \"Tinywan\"\n\ta := m3[1]\n\tfmt.Println(m3) \/\/ map[1:Tinywan]\n\tfmt.Println(a)  \/\/ Tinywan\n\n\tdelete(m3,1)  \/\/ 删除一个map\n\tfmt.Println(m3) \/\/ map[]\n\n\t\/\/ 复杂map 的操作\n\tvar m5 map[int]map[int]string \/\/ 定义\n\tm5 = make(map[int]map[int]string) \/\/ 通过 make 初始化 最外层的 map\n\t\n\tm5[1] = make(map[int]string) \/\/ 针对外层value 的map进行初始化\n\tm5[1][1] = \"OK\"\n\tm_a := m5[1][1]  \/\/ 取出map 的值赋予一个变量\n\tfmt.Println(m_a) \/\/ OK\n\n\t\/\/ 判断一个map 有没有被初始化，使用多返回值判断\n\tm_b, ok := m5[2][1]\n\t\/\/ 判断是否被初始化操作\n\tif !ok {\n\t\tm5[2] = make(map[int]string)\n\t}\n\tm5[2][1] = \"OK b\"\n\tm_b,ok = m5[2][1]\n\tfmt.Println(m_b, ok) \/\/ OK b true\n\n\t\/\/ 迭代操作\n\ts_map := make([]map[int]string,5) \/\/ 以 map 为元素的slice 使用 make 创建一个切片,元素的slic\n\tfor _,v := range s_map {\n\t\tv = make(map[int]string) \/\/ v 是值的拷贝\n\t\tv[1] = \"OK\"\n\t\tfmt.Println(v);\n\t}\n\tfmt.Println(s_map)\n\n\t\/\/ 针对一个 map 直接操作\n\tfor i := range s_map {\n\t\ts_map[i] = make(map[int]string) \n\t\ts_map[i][1] = \"OK\"\n\t\tfmt.Println(s_map[i]);\n\t}\n\tfmt.Println(s_map)\n\n\t\/\/ map 的间接排序\n\t\/\/ map 集合\n\tmap01 := map[int]string{1:\"a\", 2:\"b\", 3:\"n\", 4:\"c\", 5:\"p\", 6:\"f\"}\n\t\/\/ 切片\n\tslice01 := make([]int, len(map01))\n\ti := 0\n\tfor k, _ := range map01 {\n\t\tslice01[i] = k\n\t\ti++\n\t} \n\n\tfmt.Println(slice01) \/\/ 返回的是一个无序的数组:[5 6 1 2 3 4] [3 4 5 6 1 2]\n\tsort.Ints(slice01)\n\tfmt.Println(slice01) \/\/ 有序的数组:[1 2 3 4 5 6]\n}\n```","meta":{"mtime":""}}}
</script>

    <script src="../tmp/book/624c24de5f335/asset/lodash/lodash.min.js?v=4.17.21"></script>

    <script src="../tmp/book/624c24de5f335/asset/react/react.production.min.js?v=17.0.2"></script>

    <script src="../tmp/book/624c24de5f335/asset/react-dom/react-dom.production.min.js?v=17.0.2"></script>

    <script src="../tmp/book/624c24de5f335/asset/reader/index.js?v=1.0.24"></script>

    <script src="../tmp/book/624c24de5f335/asset/plugins/comment/index.js?v=0.0.1"></script>

    <script src="../tmp/book/624c24de5f335/asset/plugins/highlight/index.js?v=1.0.0"></script>

    <script src="../tmp/book/624c24de5f335/asset/plugins/theme-classic/index.js?v=1.0.2"></script>

<script type="text/javascript">
    TopWrite.bootstrap();
</script>
</body>
</html>
