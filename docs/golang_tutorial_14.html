<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>14 - 字符串 - 万物联网服务平台</title>
    
    
    
    
</head>
<body>
<div id="root"></div>
<script type="application/payload+json">
{"id":"yWP4GW","summary":[{"id":"","title":"第0章 远程安装","articles":[]},{"id":"","title":"第1章 介绍和安装","articles":[{"title":"1 - 介绍和安装","ref":"\/docs\/golang_tutorial_01.md","path":"\/docs\/golang_tutorial_01.html","children":[]},{"title":"2 - Hello World ","ref":"\/docs\/golang_tutorial_02.md","path":"\/docs\/golang_tutorial_02.html","children":[]}]},{"id":"","title":"第2章 变量、类型和常量","articles":[{"title":"3 - 变量","ref":"\/docs\/golang_tutorial_03.md","path":"\/docs\/golang_tutorial_03.html","children":[]},{"title":"4 - 类型","ref":"\/docs\/golang_tutorial_04.md","path":"\/docs\/golang_tutorial_04.html","children":[]},{"title":"5 - 常量","ref":"\/docs\/golang_tutorial_05.md","path":"\/docs\/golang_tutorial_05.html","children":[]}]},{"id":"","title":"第3章 函数和包","articles":[{"title":"6 - 函数","ref":"\/docs\/golang_tutorial_06.md","path":"\/docs\/golang_tutorial_06.html","children":[]},{"title":"7 - 包","ref":"\/docs\/golang_tutorial_07.md","path":"\/docs\/golang_tutorial_07.html","children":[]}]},{"id":"","title":"第4章 条件和循环语句","articles":[{"title":"8 - if else 语句","ref":"\/docs\/golang_tutorial_08.md","path":"\/docs\/golang_tutorial_08.html","children":[]},{"title":"9 - 循环语句","ref":"\/docs\/golang_tutorial_09.md","path":"\/docs\/golang_tutorial_09.html","children":[]},{"title":"10 - switch语句","ref":"\/docs\/golang_tutorial_10.md","path":"\/docs\/golang_tutorial_10.html","children":[]}]},{"id":"","title":"第5章 数组、切片和变参函数","articles":[{"title":"11 - 数组和切片","ref":"\/docs\/golang_tutorial_11.md","path":"\/docs\/golang_tutorial_11.html","children":[]},{"title":"12 - 变 参函数","ref":"\/docs\/golang_tutorial_12.md","path":"\/docs\/golang_tutorial_12.html","children":[]}]},{"id":"","title":"第6章 更多的类型","articles":[{"title":"13 - Map","ref":"\/docs\/golang_tutorial_13.md","path":"\/docs\/golang_tutorial_13.html","children":[]},{"title":"14 - 字符串","ref":"\/docs\/golang_tutorial_14.md","path":"\/docs\/golang_tutorial_14.html","children":[]}]},{"id":"","title":"第7章 指针、结构体和方法","articles":[{"title":"15 - 指针","ref":"\/docs\/golang_tutorial_15.md","path":"\/docs\/golang_tutorial_15.html","children":[]},{"title":"16 -  结构体","ref":"\/docs\/golang_tutorial_16.md","path":"\/docs\/golang_tutorial_16.html","children":[]},{"title":"17 -  方法","ref":"\/docs\/golang_tutorial_17.md","path":"\/docs\/golang_tutorial_17.html","children":[]}]},{"id":"","title":"第8章 接口","articles":[]},{"id":"","title":"第9章 并发","articles":[{"title":" 21 - 协程","ref":"\/docs\/golang_tutorial_21.md","path":"\/docs\/golang_tutorial_21.html","children":[]}]},{"id":"","title":"第10章 面向对象编程","articles":[]},{"id":"","title":"第11章 延迟和错误处理","articles":[{"title":"35 - 读文件","ref":"\/docs\/golang_tutorial_35.md","path":"\/docs\/golang_tutorial_35.html","children":[]}]},{"id":"","title":"文档","articles":[{"title":"如何编写 Go代码","ref":"\/docs\/how_to_write_go_code.md","path":"\/docs\/how_to_write_go_code.html","children":[]}]}],"config":{"pluginsConfig":{"theme-default":{"auto_open":true,"navs":[{"title":"ThinkAPI","url":"https:\/\/docs.topthink.com\/think-api\/1835085"},{"title":"Tinywan","url":"https:\/\/market.topthink.com\/website"}]}},"title":"万物联网服务平台","plugins":["highlight","comment"],"theme":"classic"},"file":{"path":"\/docs\/golang_tutorial_14.html","content":"\n14 - 字符串  \n========================\n\n上一节：[第十篇 if else 语句](\/docs\/golang_tutorial_10.md)   \n下一节：[第十二篇 包](\/docs\/golang_tutorial_12.md)  \n\n这是本Golang系列教程的第14篇。  \n\n`string` 类型单独提取为一篇教程是因为在 Go 中，`string` 的实现方式同其他语言的不同。  \n\n## 访问字符串中的字节  \n\n因为字符串是字节数组，因此可以访问一个字符串中的字节。  \n\n```golang\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n\/\/ 打印字符串中的字节\nfunc printBytes(s string) {\n\tfor i := 0; i < len(s); i++ {\n\t\tfmt.Printf(\"%x \", s[i])\n\t}\n}\n\nfunc main() {\n\tname := \"Hello World\"\n\tprintBytes(name)\n}\n```\n在上面的程序中，`len(s)` 返回字符串中的字节数，我们用一个 `for` 循环以 16 进制打印这些字节。`%x` 格式化指示符用来以 16 进制打印参数。上面的程序打印：`48 65 6c 6c 6f 20 57 6f 72 6c 64`。它们是 `\"Hello World\"` 以`UTF-8`方式编码的`Unicode`值。对 `Unicode` 字符集和 `UTF-8` 编码有一个基本的了解会更好的理解 `string` 类型。我（原文作者）建议大家阅读：https:\/\/naveenr.net\/unicode-character-set-and-utf-8-utf-16-utf-32-encoding\/ 来学习什么是 `Unicode` 和 `UTF-8`。  \n\n让我们修改上面的程序以打印字符串中的字符：  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc printBytes(s string) {  \n    for i:= 0; i < len(s); i++ {\n        fmt.Printf(\"%x \", s[i])\n    }\n}\n\n\nfunc printChars(s string) {  \n    for i:= 0; i < len(s); i++ {\n        fmt.Printf(\"%c \",s[i])\n    }\n}\n\nfunc main() {  \n    name := \"Hello World\"\n    printBytes(name)\n    fmt.Printf(\"\\n\")\n    printChars(name)\n}\n```\n在第 16 行的 `printChars` 函数中，`%c` 格式化指示符用来打印字符串中的字符。上面的程序输出为：\n\n```golang\n48 65 6c 6c 6f 20 57 6f 72 6c 64\nHello World\n```\n\n虽然上面的程序看起来是一种合法的打印字符串中各个字符的方法，但是这里有一个严重的错误。让我们深入这段代码看看究竟是哪里不对。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc printBytes(s string) {  \n    for i:= 0; i < len(s); i++ {\n        fmt.Printf(\"%x \", s[i])\n    }\n}\n\nfunc printChars(s string) {  \n    for i:= 0; i < len(s); i++ {\n        fmt.Printf(\"%c \",s[i])\n    }\n}\n\nfunc main() {  \n    name := \"Hello World\"\n    printBytes(name)\n    fmt.Printf(\"\\n\")\n    printChars(name)\n    fmt.Printf(\"\\n\")\n    name = \"Señor\"\n    printBytes(name)\n    fmt.Printf(\"\\n\")\n    printChars(name)\n}\n```\n上面程序的输出为：  \n```golang\n48 65 6c 6c 6f 20 57 6f 72 6c 64\nHello World\n53 65 c3 b1 6f 72\nSeÃ±or\n```\n\n## rune  \n\n`rune` 是 Go 中的内置类型，它是 `int32` 的别名。在 Go 中，`rune` 表示一个 `Unicode` 码点。无论一个码点会被编码为多少个字节，它都可以表示为一个 `rune`。让我们修改上面的程序，使用 `rune` 来打印字符串中的字符。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc printBytes(s string) {  \n    for i:= 0; i < len(s); i++ {\n        fmt.Printf(\"%x \", s[i])\n    }\n}\n\nfunc printChars(s string) {  \n    runes := []rune(s)\n    for i:= 0; i < len(runes); i++ {\n        fmt.Printf(\"%c \",runes[i])\n    }\n}\n\nfunc main() {  \n    name := \"Hello World\"\n    printBytes(name)\n    fmt.Printf(\"\\n\")\n    printChars(name)\n    fmt.Printf(\"\\n\\n\")\n    name = \"Señor\"\n    printBytes(name)\n    fmt.Printf(\"\\n\")\n    printChars(name)\n}\n```\n\n在上面的程序中，第 14 行，字符串被转换为 `tune` 切片。然后我们遍历该切片并打印其中的字符。程序的输出如下：  \n\n```golang\n48 65 6c 6c 6f 20 57 6f 72 6c 64\nHello World\n53 65 c3 b1 6f 72\nSeñor\n```\n上面的输出是正确的。这正是我们想要的结果。  \n\n## 使用 range for 遍历字符串  \n\n上面的程序是遍历字符串中字符的一个正确方式。但是 Go 提供了一种更简单的方式来做到这一点：使用 `range` `for`。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc printCharsAndBytes(s string) {  \n    for index, rune := range s {\n        fmt.Printf(\"%c starts at byte %d\\n\", rune, index)\n    }\n}\n\nfunc main() {  \n    name := \"Señor\"\n    printCharsAndBytes(name)\n}\n```\n\n在上面的程序中，第 8 行通过使用 `range for` 遍历字符串。`range` 返回一个 `rune` （在 `byte` 数组中）的位置，以及 `rune` 本身。上面的程序输出为：  \n\n```golang\nS starts at byte 0\ne starts at byte 1\nñ starts at byte 2\no starts at byte 4\nr starts at byte 5\n```\n\n从上面的输出可以看到，ñ 占两个字节：）\n\n## 通过 `byte` 切片创建字符串  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    byteSlice := []byte{0x43, 0x61, 0x66, 0xC3, 0xA9}\n    str := string(byteSlice)\n    fmt.Println(str)\n}\n```\n在上面的程序中，`byteSlice` 是 `\"Café\"` 经过 `UTF-8` 编码后得到的切片（用 16 进制表示） 。上面的程序输出为：`Café`。  \n\n如果我们换成对应的十进制数程序会正常工作吗？答案是：`Yes`。让我们测试一下：  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    byteSlice := []byte{67, 97, 102, 195, 169} \/\/decimal equivalent of {'\\x43', '\\x61', '\\x66', '\\xC3', '\\xA9'}\n    str := string(byteSlice)\n    fmt.Println(str)\n}\n```\n上面的程序同样输出：`Café`。  \n\n## 通过 rune 切片创建字符串  \n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc main() {  \n    runeSlice := []rune{0x0053, 0x0065, 0x00f1, 0x006f, 0x0072}\n    str := string(runeSlice)\n    fmt.Println(str)\n}\n```\n在上面的程序中，`runeSlice` 包含了字符串 `\"Señor\"` 的 `Unicode` 码点（以 16 进制表示）。程序的输出为：`Señor`。  \n\n## 字符串的长度  \nutf8 包 提供了 `func RuneCountInString(s string) (n int)` 来获取字符串的长度，该方法接受一个字符串作为参数，并返回该字符串中 `rune` 的数量。  \n\n（译者注： `RuneCountInString` 返回字符串中 `Unicode` 字符的个数，而 `len` 返回字符串中 `byte` 的个数，注意两者的区别。 ）  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n    \"unicode\/utf8\"\n)\n\nfunc length(s string) {  \n    fmt.Printf(\"length of %s is %d\\n\", s, utf8.RuneCountInString(s))\n}\nfunc main() {  \n\n    word1 := \"Señor\" \n    length(word1)\n    word2 := \"Pets\"\n    length(word2)\n}\n```\n\n上面程序的输出为：  \n\n```golang\nlength of Señor is 5  \nlength of Pets is 4 \n```\n\n##  字符串是不可变的   \n\n在 Go 中字符串是不可变的。字符串一旦被创建就无法改变。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc mutate(s string)string {  \n    s[0] = 'a'\/\/any valid unicode character within single quote is a rune \n    return s\n}\nfunc main() {  \n    h := \"hello\"\n    fmt.Println(mutate(h))\n}\n```\n\n上面的程序中，第 8 行我们试图改变字符串的第一个字符为 `a`。因为字符串是不可变的，因此这是非法的，将会报错：`main.go:8: cannot assign to s[0]`。  \n\n为了改变一个字符串中的字符，我们需要先把字符串转换为 `rune` 切片，然后修改切片中的内容，最后将这个切片转换回字符串。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc mutate(s []rune) string {  \n    s[0] = 'a' \n    return string(s)\n}\nfunc main() {  \n    h := \"hello\"\n    fmt.Println(mutate([]rune(h)))\n}\n```\n\n在上面的程序中，第 7 行 `mutate` 函数接受一个 `rune` 切片作为参数。然后将该切片的第一个元素改为 `a`，最后再转换回字符串并返回。该函数在程序中的第 13 行被调用。`h` 被转换为一个 `rune` 切片传递给 `mutate`。程序的输出为：`aello`。\n\n字符串的介绍到此为止。感谢阅读。  \n","meta":{"mtime":""}}}
</script>

    <script src="../tmp/book/624c24de5f335/asset/lodash/lodash.min.js?v=4.17.21"></script>

    <script src="../tmp/book/624c24de5f335/asset/react/react.production.min.js?v=17.0.2"></script>

    <script src="../tmp/book/624c24de5f335/asset/react-dom/react-dom.production.min.js?v=17.0.2"></script>

    <script src="../tmp/book/624c24de5f335/asset/reader/index.js?v=1.0.24"></script>

    <script src="../tmp/book/624c24de5f335/asset/plugins/comment/index.js?v=0.0.1"></script>

    <script src="../tmp/book/624c24de5f335/asset/plugins/highlight/index.js?v=1.0.0"></script>

    <script src="../tmp/book/624c24de5f335/asset/plugins/theme-classic/index.js?v=1.0.2"></script>

<script type="text/javascript">
    TopWrite.bootstrap();
</script>
</body>
</html>
