<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>17 -  方法 - 万物联网服务平台</title>
    
    
    
    
</head>
<body>
<div id="root"></div>
<script type="application/payload+json">
{"id":"yWP4GW","summary":[{"id":"","title":"第0章 远程安装","articles":[]},{"id":"","title":"第1章 介绍和安装","articles":[{"title":"1 - 介绍和安装","ref":"\/docs\/golang_tutorial_01.md","path":"\/docs\/golang_tutorial_01.html","children":[]},{"title":"2 - Hello World ","ref":"\/docs\/golang_tutorial_02.md","path":"\/docs\/golang_tutorial_02.html","children":[]}]},{"id":"","title":"第2章 变量、类型和常量","articles":[{"title":"3 - 变量","ref":"\/docs\/golang_tutorial_03.md","path":"\/docs\/golang_tutorial_03.html","children":[]},{"title":"4 - 类型","ref":"\/docs\/golang_tutorial_04.md","path":"\/docs\/golang_tutorial_04.html","children":[]},{"title":"5 - 常量","ref":"\/docs\/golang_tutorial_05.md","path":"\/docs\/golang_tutorial_05.html","children":[]}]},{"id":"","title":"第3章 函数和包","articles":[{"title":"6 - 函数","ref":"\/docs\/golang_tutorial_06.md","path":"\/docs\/golang_tutorial_06.html","children":[]},{"title":"7 - 包","ref":"\/docs\/golang_tutorial_07.md","path":"\/docs\/golang_tutorial_07.html","children":[]}]},{"id":"","title":"第4章 条件和循环语句","articles":[{"title":"8 - if else 语句","ref":"\/docs\/golang_tutorial_08.md","path":"\/docs\/golang_tutorial_08.html","children":[]},{"title":"9 - 循环语句","ref":"\/docs\/golang_tutorial_09.md","path":"\/docs\/golang_tutorial_09.html","children":[]},{"title":"10 - switch语句","ref":"\/docs\/golang_tutorial_10.md","path":"\/docs\/golang_tutorial_10.html","children":[]}]},{"id":"","title":"第5章 数组、切片和变参函数","articles":[{"title":"11 - 数组和切片","ref":"\/docs\/golang_tutorial_11.md","path":"\/docs\/golang_tutorial_11.html","children":[]},{"title":"12 - 变 参函数","ref":"\/docs\/golang_tutorial_12.md","path":"\/docs\/golang_tutorial_12.html","children":[]}]},{"id":"","title":"第6章 更多的类型","articles":[{"title":"13 - Map","ref":"\/docs\/golang_tutorial_13.md","path":"\/docs\/golang_tutorial_13.html","children":[]},{"title":"14 - 字符串","ref":"\/docs\/golang_tutorial_14.md","path":"\/docs\/golang_tutorial_14.html","children":[]}]},{"id":"","title":"第7章 指针、结构体和方法","articles":[{"title":"15 - 指针","ref":"\/docs\/golang_tutorial_15.md","path":"\/docs\/golang_tutorial_15.html","children":[]},{"title":"16 -  结构体","ref":"\/docs\/golang_tutorial_16.md","path":"\/docs\/golang_tutorial_16.html","children":[]},{"title":"17 -  方法","ref":"\/docs\/golang_tutorial_17.md","path":"\/docs\/golang_tutorial_17.html","children":[]}]},{"id":"","title":"第8章 接口","articles":[]},{"id":"","title":"第9章 并发","articles":[{"title":" 21 - 协程","ref":"\/docs\/golang_tutorial_21.md","path":"\/docs\/golang_tutorial_21.html","children":[]}]},{"id":"","title":"第10章 面向对象编程","articles":[]},{"id":"","title":"第11章 延迟和错误处理","articles":[{"title":"35 - 读文件","ref":"\/docs\/golang_tutorial_35.md","path":"\/docs\/golang_tutorial_35.html","children":[]}]},{"id":"","title":"文档","articles":[{"title":"如何编写 Go代码","ref":"\/docs\/how_to_write_go_code.md","path":"\/docs\/how_to_write_go_code.html","children":[]}]}],"config":{"pluginsConfig":{"theme-default":{"auto_open":true,"navs":[{"title":"ThinkAPI","url":"https:\/\/docs.topthink.com\/think-api\/1835085"},{"title":"Tinywan","url":"https:\/\/market.topthink.com\/website"}]}},"title":"万物联网服务平台","plugins":["highlight","comment"],"theme":"classic"},"file":{"path":"\/docs\/golang_tutorial_17.html","content":"\n17 - 方法  \n========================\n\n上一节：[第十六篇 结构体](\/docs\/golang_tutorial_16.md)  \n下一节：[第十八篇 接口一](\/docs\/golang_tutorial_18.md)  \n\n这是本Golang系列教程的第17篇。   \n\n## 什么是方法？  \n\n一个方法只是一个函数，它有一个特殊的接收者（`receiver`）类型，该接收者放在 `func` 关键字和函数名之间。接收者可以是结构体类型或非结构体类型。可以在方法内部访问接收者。  \n\n通过下面的语法创建一个方法：  \n\n```golang\nfunc (t Type) methodName(parameter list) {  \n}\n```\n\n上面的代码片段创建了一个名为 `methodName` 的方法，该方法有一个类型为 Type 的接收者。  \n\n## 案例  \n\n让我们编写一个简单的程序，它创建一个结构体类型的方法并调用它。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\ntype Employee struct {  \n    name     string\n    salary   int\n    currency string\n}\n\n\/*\n displaySalary() method has Employee as the receiver type\n*\/\nfunc (e Employee) displaySalary() {  \n    fmt.Printf(\"Salary of %s is %s%d\", e.name, e.currency, e.salary)\n}\n\nfunc main() {  \n    emp1 := Employee {\n        name:     \"Sam Adolf\",\n        salary:   5000,\n        currency: \"$\",\n    }\n    emp1.displaySalary() \/\/Calling displaySalary() method of Employee type\n}\n```\n[在 Playground 中运行](https:\/\/play.golang.org\/p\/3khFtFJdbee)  \n\n上面程序的第 6 行，我们为 `Employee` 创建了一个名为 `displaySalary` 的方法。在 `displaySalary()` 方法内部可以访问它的接收者 `e` （类型为 `Employee`）。在第 17 行，我们使用接收者 `e`，并打印它的 `name`，`currency` 以及 `salary`。  \n\n程序的输出为:   \n\n```golang\nSalary of Sam Adolf is $5000 \n```\n\n## 为什么使用方法而不是函数？  \n\n上面的程序可以使用函数而不是方法重写如下：  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\ntype Employee struct {  \n    name     string\n    salary   int\n    currency string\n}\n\n\/*\n displaySalary() method converted to function with Employee as parameter\n*\/\nfunc displaySalary(e Employee) {  \n    fmt.Printf(\"Salary of %s is %s%d\", e.name, e.currency, e.salary)\n}\n\nfunc main() {  \n    emp1 := Employee{\n        name:     \"Sam Adolf\",\n        salary:   5000,\n        currency: \"$\",\n    }\n    displaySalary(emp1)\n}\n```\n\n[在 Playground 中运行](https:\/\/play.golang.org\/p\/xKqdal-DqHT)   \n\n在上面的程序中，我们使用 `displaySalary` 函数替换了方法，并将 `Employee` 结构体作为参数传给它。该程序的输出与上面的程序输出一样：`Salary of Sam Adolf is $5000`。  \n\n那么为什么我们可以用函数完成同样的工作，却还要使用方法呢？这里有几个原因，我们一个一个地看。  \n\n* [Go 不是一个纯面向对象的编程语言](https:\/\/golang.org\/doc\/faq#Is_Go_an_object-oriented_language)，它不支持 `class` 类型。因此通过在一个类型上建立方法来实现与 `class` 相似的行为。  \n* 同名方法可以定义在不同的类型上，但是 Go 不允许同名函数。假设我们有一个 `Square` 和 `Circle` 两个结构体。在 `Square` 和 `Circle` 上定义同名的方法是合法的，比如下面的程序：     \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n    \"math\"\n)\n\ntype Rectangle struct {  \n    length int\n    width  int\n}\n\ntype Circle struct {  \n    radius float64\n}\n\nfunc (r Rectangle) Area() int {  \n    return r.length * r.width\n}\n\nfunc (c Circle) Area() float64 {  \n    return math.Pi * c.radius * c.radius\n}\n\nfunc main() {  \n    r := Rectangle{\n        length: 10,\n        width:  5,\n    }\n    fmt.Printf(\"Area of rectangle %d\\n\", r.Area())\n    c := Circle{\n        radius: 12,\n    }\n    fmt.Printf(\"Area of circle %f\", c.Area())\n}\n```\n\n程序的输出为：  \n```golang\nArea of rectangle 50  \nArea of circle 452.389342  \n```\n\n接口正是应用了这一点（译者注：*相同的方法名可以用在不同的接收者类型上*）。我们将在下面的教程中讨论接口的细节。  \n\n##  指针接收者 vs. 值接收者  \n\n目前为止我们看到的都是以值作为接收者。以指针为接收者也是可以的。两者的区别在于，以指针作为接收者时，方法内部对其的修改对于调用者是可见的，但是以值作为接收者却不是。让我们通过下面的程序帮助理解。   \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\ntype Employee struct {  \n    name string\n    age  int\n}\n\n\/*\nMethod with value receiver  \n*\/\nfunc (e Employee) changeName(newName string) {  \n    e.name = newName\n}\n\n\/*\nMethod with pointer receiver  \n*\/\nfunc (e *Employee) changeAge(newAge int) {  \n    e.age = newAge\n}\n\nfunc main() {  \n    e := Employee{\n        name: \"Mark Andrew\",\n        age:  50,\n    }\n    fmt.Printf(\"Employee name before change: %s\", e.name)\n    e.changeName(\"Michael Andrew\")\n    fmt.Printf(\"\\nEmployee name after change: %s\", e.name)\n\n    fmt.Printf(\"\\n\\nEmployee age before change: %d\", e.age)\n    (&e).changeAge(51)\n    fmt.Printf(\"\\nEmployee age after change: %d\", e.age)\n}\n```\n\n上面的程序中， `changeName` 方法有一个值接收者 (`e Employee`)，而 `changeAge` 方法有一个指针接收者 (`e *Employee`)。在 `changeName` 中改变 `Employee` 的字段 `name` 的值对调用者而言是不可见的，因此程序在调用 `e.changeName(\"Michael Andrew\")` 方法之前和之后，打印的 `name` 是一致的。而因为 `changeAge` 的接受者是一个指针 (`e *Employee`)，因此通过调用方法 `(&e).changeAge(51)` 来修改 `age` 对于调用者是可见的。 程序的输出如下：  \n\n```golang\nEmployee name before change: Mark Andrew  \nEmployee name after change: Mark Andrew\n\nEmployee age before change: 50  \nEmployee age after change: 51\n```\n\n在上面的程序第36行，我们用 `(&e).changeAge(51)` 来调用 `changeAge` 方法。因为 `changeAge` 有一个指针类型的接收者我们必须使用 `(&e)` 来调用。这不是必须的，Go允许我们省略 `&` 符号，因此可以只写为 `e.changeAge(51)`。Go 将 `e.changeAge(51)` 解析为 `(&e).changeAge(51)`。  \n\n下面的程序使用 `e.changeAge(51)` 来替代 `(&e).changeAge(51)`。它与上面的程序的打印结果是一样的。  \n\n程序的输出为：  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\ntype Employee struct {  \n    name string\n    age  int\n}\n\n\/*\nMethod with value receiver  \n*\/\nfunc (e Employee) changeName(newName string) {  \n    e.name = newName\n}\n\n\/*\nMethod with pointer receiver  \n*\/\nfunc (e *Employee) changeAge(newAge int) {  \n    e.age = newAge\n}\n\nfunc main() {  \n    e := Employee{\n        name: \"Mark Andrew\",\n        age:  50,\n    }\n    fmt.Printf(\"Employee name before change: %s\", e.name)\n    e.changeName(\"Michael Andrew\")\n    fmt.Printf(\"\\nEmployee name after change: %s\", e.name)\n\n    fmt.Printf(\"\\n\\nEmployee age before change: %d\", e.age)\n    e.changeAge(51)\n    fmt.Printf(\"\\nEmployee age after change: %d\", e.age)\n}  \n```\n\n## 何时使用指针接收者，何时使用值接收者？  \n\n一般来讲，指针接收者可用于对接收者的修改应该对调用者可以见的场合。  \n\n指针接收者也可用于拷贝结构体代价较大的场合。考虑一个包含较多字段的结构体，若使用值作为接收者则必须拷贝整个结构体，这样的代价很大。这种情况下使用指针接收者将避免结构体的拷贝，而仅仅是指向结构体指针的拷贝。  \n\n其他情况下可以使用值接收者。  \n\n## 匿名字段函数  \n\n匿名字段的方法可以被包含该匿名字段的结构体的变量调用，就好像该匿名字段的方法属于包含该字段的结构体一样。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\ntype address struct {  \n    city  string\n    state string\n}\n\nfunc (a address) fullAddress() {  \n    fmt.Printf(\"Full address: %s, %s\", a.city, a.state)\n}\n\ntype person struct {  \n    firstName string\n    lastName  string\n    address\n}\n\nfunc main() {  \n    p := person{\n        firstName: \"Elon\",\n        lastName:  \"Musk\",\n        address: address {\n            city:  \"Los Angeles\",\n            state: \"California\",\n        },\n    }\n    p.fullAddress() \/\/accessing fullAddress method of address struct\n}\n```\n\n在上面的程序中，第32行，我们通过 `p.fullAddress()` 调用了 `address` 的方法 `fullAddress()`。像 `p.address.fullAddress()` 这样的直接调用是不必要的。程序的输出为：  \n\n```golang\nFull address: Los Angeles, California \n```\n\n##  方法的值接收者 vs. 函数的值参数  \n\n这是很多新手遇到的问题。我们将尽可能把它说明白。  \n\n当一个函数有一个值参数时，它只接受一个值参数。  \n\n当一个方法有一个值接收者时，它可以接受值和指针接收者。  \n\n让我们通过程序说明这一点。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\ntype rectangle struct {  \n    length int\n    width  int\n}\n\nfunc area(r rectangle) {  \n    fmt.Printf(\"Area Function result: %d\\n\", (r.length * r.width))\n}\n\nfunc (r rectangle) area() {  \n    fmt.Printf(\"Area Method result: %d\\n\", (r.length * r.width))\n}\n\nfunc main() {  \n    r := rectangle{\n        length: 10,\n        width:  5,\n    }\n    area(r)\n    r.area()\n\n    p := &r\n    \/*\n       compilation error, cannot use p (type *rectangle) as type rectangle \n       in argument to area  \n    *\/\n    \/\/area(p)\n\n    p.area()\/\/calling value receiver with a pointer\n}\n```\n\n第12行，函数 `func area(r rectangle)` 接受一个值参数，而方法 `func (r rectangle) area()` 接受一个值接收者。\n\n在第25行，我们传递了一个值来调用 `area` 函数 `area(r)`，它将工作。同样地，我们通过值接收者调用 `area` 方法 `r.area()` 它也可以工作。\n\n在第28行，我们创建了一个指向 `r` 的指针 `p`。如果我们试图将这个指针传递给只接受值的 area 函数那么编译器将报错：`compilation error, cannot use p (type *rectangle) as type rectangle in argument to area`.。这是我们预期的。\n\n现在来到了微妙的地方，第35行 `p.area()` 使用指针接收者 `p` 调用了接受一个值接收者的方法 `area` 。这是完全合法的。原因是对于 `p.area()`，Go 将其解析为 `(&p).area()`，因为 `area` 方法必须接受一个值接收者。这是为了方便 Go 给我们提供的语法糖。\n\n程序的输出为：  \n\n```golang\nArea Function result: 50  \nArea Method result: 50  \nArea Method result: 50 \n```\n\n## 方法的指针接收者 vs. 函数的指针参数  \n\n与值参数相似，一个接受指针参数的函数只能接受指针，而一个接收者为指针的方法可以接受值接收者和指针接收者。   \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\ntype rectangle struct {  \n    length int\n    width  int\n}\n\nfunc perimeter(r *rectangle) {  \n    fmt.Println(\"perimeter function output:\", 2*(r.length+r.width))\n\n}\n\nfunc (r *rectangle) perimeter() {  \n    fmt.Println(\"perimeter method output:\", 2*(r.length+r.width))\n}\n\nfunc main() {  \n    r := rectangle{\n        length: 10,\n        width:  5,\n    }\n    p := &r \/\/pointer to r\n    perimeter(p)\n    p.perimeter()\n\n    \/*\n        cannot use r (type rectangle) as type *rectangle in argument to perimeter\n    *\/\n    \/\/perimeter(r)\n\n    r.perimeter()\/\/calling pointer receiver with a value\n}\n```\n\n在上面的程序中，第12行定义了一个函数 `perimeter`，该函数接受一个指针作为参数，而17行定义了一个方法，有一个指针接收者。  \n\n27行我们通过指针参数调用 `perimeter` 函数，在第28行我们通过一个指针接收者调用 `perimeter` 方法。一切都好。  \n\n在被注释掉的第33行，我们试图通以一个值 `r` 调用 `perimeter` 函数。这是非法的，因为一个接受指针为参数的函数不能接受一个值作为参数。如果去掉注释运行程序，则编译将报错：`main.go:33: cannot use r (type rectangle) as type *rectangle in argument to perimeter.`。  \n\n在第35行我们通过一个值接收者 `r` 调用接受一个指针接收者的 `perimeter` 方法。这是合法的，`r.perimeter()` 这一行将被 Go 解析为 `(&r).perimeter()`。这是为了方便 Go 给我们提供的语法糖。程序的输出为：  \n\n```golang\nperimeter function output: 30  \nperimeter method output: 30  \nperimeter method output: 30  \n```\n\n## 定义非结构体类型的方法  \n\n现在我们定义的都是结构体类型的方法。同样可以定义非结构体类型的方法，不过这里需要注意一点。为了定义某个类型的方法，接收者类型的定义与方法的定义必须在同一个包中。目前为止，我们定义的结构体和相应的方法都是在`main`包中的，因此没有任何问题。   \n\n```golang\npackage main\n\nfunc (a int) add(b int) {  \n}\n\nfunc main() {\n\n}\n```\n\n在上面的程序中，第3行我们试图添加一个方法 `add` 给内置类型 `int`。这是不允许的，因为定义方法 add 所在的包和定义类型 `int` 的包不是同一个包。这个程序将会报编译错误：`cannot define new methods on non-local type int`。  \n\n使其工作的方法为定义内置类型的别名，然后以这个新类型为接收者创建方法。   \n\n```golang\npackage main\n\nimport \"fmt\"\n\ntype myInt int\n\nfunc (a myInt) add(b myInt) myInt {  \n    return a + b\n}\n\nfunc main() {  \n    num1 := myInt(5)\n    num2 := myInt(10)\n    sum := num1.add(num2)\n    fmt.Println(\"Sum is\", sum)\n}\n```\n\n上面的程序中，第5行，我们创建了新的类型，一个 `int` 的别名 `myInt`。在第7行，我们定义了一个方法 add，以 `myInt` 作为接收者。  \n\n程序的输出为： `Sum is 15`。  \n\n我已经创建了一个程序，其中包含了目前为止所讨论的所有概念，可以在 github 上找到它。  \n\n希望你喜欢阅读。请留下宝贵的意见和反馈:)  ","meta":{"mtime":""}}}
</script>

    <script src="../tmp/book/624c24de5f335/asset/lodash/lodash.min.js?v=4.17.21"></script>

    <script src="../tmp/book/624c24de5f335/asset/react/react.production.min.js?v=17.0.2"></script>

    <script src="../tmp/book/624c24de5f335/asset/react-dom/react-dom.production.min.js?v=17.0.2"></script>

    <script src="../tmp/book/624c24de5f335/asset/reader/index.js?v=1.0.24"></script>

    <script src="../tmp/book/624c24de5f335/asset/plugins/comment/index.js?v=0.0.1"></script>

    <script src="../tmp/book/624c24de5f335/asset/plugins/highlight/index.js?v=1.0.0"></script>

    <script src="../tmp/book/624c24de5f335/asset/plugins/theme-classic/index.js?v=1.0.2"></script>

<script type="text/javascript">
    TopWrite.bootstrap();
</script>
</body>
</html>
