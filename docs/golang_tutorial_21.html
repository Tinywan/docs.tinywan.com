<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title> 21 - 协程 - 万物联网服务平台</title>
    
    
    
    
</head>
<body>
<div id="root"></div>
<script type="application/payload+json">
{"id":"yWP4GW","summary":[{"id":"","title":"第0章 远程安装","articles":[]},{"id":"","title":"第1章 介绍和安装","articles":[{"title":"1 - 介绍和安装","ref":"\/docs\/golang_tutorial_01.md","path":"\/docs\/golang_tutorial_01.html","children":[]},{"title":"2 - Hello World ","ref":"\/docs\/golang_tutorial_02.md","path":"\/docs\/golang_tutorial_02.html","children":[]}]},{"id":"","title":"第2章 变量、类型和常量","articles":[{"title":"3 - 变量","ref":"\/docs\/golang_tutorial_03.md","path":"\/docs\/golang_tutorial_03.html","children":[]},{"title":"4 - 类型","ref":"\/docs\/golang_tutorial_04.md","path":"\/docs\/golang_tutorial_04.html","children":[]},{"title":"5 - 常量","ref":"\/docs\/golang_tutorial_05.md","path":"\/docs\/golang_tutorial_05.html","children":[]}]},{"id":"","title":"第3章 函数和包","articles":[{"title":"6 - 函数","ref":"\/docs\/golang_tutorial_06.md","path":"\/docs\/golang_tutorial_06.html","children":[]},{"title":"7 - 包","ref":"\/docs\/golang_tutorial_07.md","path":"\/docs\/golang_tutorial_07.html","children":[]}]},{"id":"","title":"第4章 条件和循环语句","articles":[{"title":"8 - if else 语句","ref":"\/docs\/golang_tutorial_08.md","path":"\/docs\/golang_tutorial_08.html","children":[]},{"title":"9 - 循环语句","ref":"\/docs\/golang_tutorial_09.md","path":"\/docs\/golang_tutorial_09.html","children":[]},{"title":"10 - switch语句","ref":"\/docs\/golang_tutorial_10.md","path":"\/docs\/golang_tutorial_10.html","children":[]}]},{"id":"","title":"第5章 数组、切片和变参函数","articles":[{"title":"11 - 数组和切片","ref":"\/docs\/golang_tutorial_11.md","path":"\/docs\/golang_tutorial_11.html","children":[]},{"title":"12 - 变 参函数","ref":"\/docs\/golang_tutorial_12.md","path":"\/docs\/golang_tutorial_12.html","children":[]}]},{"id":"","title":"第6章 更多的类型","articles":[{"title":"13 - Map","ref":"\/docs\/golang_tutorial_13.md","path":"\/docs\/golang_tutorial_13.html","children":[]},{"title":"14 - 字符串","ref":"\/docs\/golang_tutorial_14.md","path":"\/docs\/golang_tutorial_14.html","children":[]}]},{"id":"","title":"第7章 指针、结构体和方法","articles":[{"title":"15 - 指针","ref":"\/docs\/golang_tutorial_15.md","path":"\/docs\/golang_tutorial_15.html","children":[]},{"title":"16 -  结构体","ref":"\/docs\/golang_tutorial_16.md","path":"\/docs\/golang_tutorial_16.html","children":[]},{"title":"17 -  方法","ref":"\/docs\/golang_tutorial_17.md","path":"\/docs\/golang_tutorial_17.html","children":[]}]},{"id":"","title":"第8章 接口","articles":[]},{"id":"","title":"第9章 并发","articles":[{"title":" 21 - 协程","ref":"\/docs\/golang_tutorial_21.md","path":"\/docs\/golang_tutorial_21.html","children":[]}]},{"id":"","title":"第10章 面向对象编程","articles":[]},{"id":"","title":"第11章 延迟和错误处理","articles":[{"title":"35 - 读文件","ref":"\/docs\/golang_tutorial_35.md","path":"\/docs\/golang_tutorial_35.html","children":[]}]},{"id":"","title":"文档","articles":[{"title":"如何编写 Go代码","ref":"\/docs\/how_to_write_go_code.md","path":"\/docs\/how_to_write_go_code.html","children":[]}]}],"config":{"pluginsConfig":{"theme-default":{"auto_open":true,"navs":[{"title":"ThinkAPI","url":"https:\/\/docs.topthink.com\/think-api\/1835085"},{"title":"Tinywan","url":"https:\/\/market.topthink.com\/website"}]}},"title":"万物联网服务平台","plugins":["highlight","comment"],"theme":"classic"},"file":{"path":"\/docs\/golang_tutorial_21.html","content":"\n21 - 协程  \n========================\n\n上一节：[第十六篇 结构体](\/docs\/golang_tutorial_16.md)  \n下一节：[第十八篇 接口一](\/docs\/golang_tutorial_18.md)  \n\n这是本Golang系列教程的第21篇。   \n\n在上一篇教程中，我们讨论了并发，以及并发和并行的区别。在这篇教程中我们将讨论在Go中如何通过Go协程实现并发。  \n\n## 什么是协程？  \n\nGo协程（`Goroutine`）是与其他[函数](\/docs\/golang_tutorial_6.md)或[方法](\/docs\/golang_tutorial_17.md)同时运行的函数或方法。可以认为Go协程是轻量级的线程。与创建线程相比，创建Go协程的成本很小。因此在Go中同时运行上千个协程是很常见的。   \n\n## Go协程对比线程的优点  \n\n* 与线程相比，Go协程的开销非常小。Go协程的堆栈大小只有几kb，它可以根据应用程序的需要而增长和缩小，而线程必须指定堆栈的大小，并且堆栈的大小是固定的。  \n* Go协程被多路复用到较少的OS线程。在一个程序中数千个Go协程可能只运行在一个线程中。如果该线程中的任何一个Go协程阻塞（比如等待用户输入），那么Go会创建一个新的OS线程并将其余的Go协程移动到这个新的OS线程。所有这些操作都是 runtime 来完成的，而我们程序员不必关心这些复杂的细节，只需要利用 Go 提供的简洁的 API 来处理并发就可以了。  \n* Go 协程之间通过信道（`channel`）进行通信。信道可以防止多个协程访问共享内存时发生竟险（race condition）。信道可以想象成多个协程之间通信的管道。我们将在下一篇教程中介绍信道。  \n\n## 如何创建一个协程？   \n\n在函数或方法调用之前加上关键字 `go`，这样便开启了一个并发的Go协程。  \n\n让我们创建一个协程：  \n```golang\npackage main\n\nimport (  \n    \"fmt\"\n)\n\nfunc hello() {  \n    fmt.Println(\"Hello world goroutine\")\n}\nfunc main() {  \n    go hello()\n    fmt.Println(\"main function\")\n}\n```\n\n第11行，`go hello()` 开启了一个新的协程。现在 `hello()` 函数将和 `main()` 函数一起运行。`main` 函数在单独的协程中运行，这个协程称为主协程。  \n\n运行这个程序，你将得到一个惊喜。程序仅输出了一行文本： `main function`。  \n\n**我们创建的协程发生了什么？我们需要了解Go协程的两个属性，以了解为什么发生这种情况。**  \n\n* 当创建一个Go协程时，创建这个Go协程的语句立即返回。与函数不同，程序流程不会等待Go协程结束再继续执行。程序流程在开启Go协程后立即返回并开始执行下一行代码，忽略Go协程的任何返回值。  \n* 在主协程存在时才能运行其他协程，主协程终止则程序终止，其他协程也将终止。  \n\n我想你已经知道了为什么我们的协程为什么没有运行。在11行调用 `go hello()`后，程序的流程直接调转到下一条语句执行，并没有等待 `hello` 协程退出，然后打印 `main function`。\n\n接着主协程结束运行，不会再执行任何代码，因此 `hello` 协程没有得到运行的机会。  \n\n让我们修复这个问题：  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n    \"time\"\n)\n\nfunc hello() {  \n    fmt.Println(\"Hello world goroutine\")\n}\nfunc main() {  \n    go hello()\n    time.Sleep(1 * time.Second)\n    fmt.Println(\"main function\")\n}\n```\n\n上面的程序中，第13行，我们调用 `time` 包的 `Sleep` 函数来使调用该函数所在的协程休眠。在这里是让主协程休眠1秒钟。现在调用 `go hello()` 有了足够的时间得以在主协程退出之前执行。该程序首先打印 `Hello world goroutine`，等待1秒钟之后打印 `main function`。  \n\n在主协程中使用 `Sleep` 函数等待其他协程结束的方法是不正规的，我们用在这里只是为了说明**Go协程**是如何工作的。信道可以用于阻塞主协程，直到其他协程执行完毕。我们将在下一篇教程中讨论信道。  \n\n## 开启多个协程  \n\n让我们写一个程序开启多个协程来更好的理解协程。  \n\n```golang\npackage main\n\nimport (  \n    \"fmt\"\n    \"time\"\n)\n\nfunc numbers() {  \n    for i := 1; i <= 5; i++ {\n        time.Sleep(250 * time.Millisecond)\n        fmt.Printf(\"%d \", i)\n    }\n}\nfunc alphabets() {  \n    for i := 'a'; i <= 'e'; i++ {\n        time.Sleep(400 * time.Millisecond)\n        fmt.Printf(\"%c \", i)\n    }\n}\nfunc main() {  \n    go numbers()\n    go alphabets()\n    time.Sleep(3000 * time.Millisecond)\n    fmt.Println(\"main terminated\")\n}\n```\n\n上面的程序在第21和22行开启了两个协程。现在这两个协程同时执行。`numbers` 协程最初睡眠 `250` 毫秒，然后打印 `1`，接着再次睡眠然后打印`2`，以此类推，直到打印到 `5`。类似地，`alphabets` 协程打印从 `a` 到 `e` 的字母，每个字母之间相隔 `400` 毫秒。主协程开启 `numbers` 和 `alphabets` 协程，等待 `3000` 毫秒，最后终止。  \n\n程序的输出为：  \n\n```golang\n1 a 2 3 b 4 c 5 d e main terminated\n```\n\n下面的图片描述了这个程序是如何工作的，请在新的标签中打开图像以获得更好的效果：）  \n\n![Goroutines-explained](..\/images\/Goroutines-explained.png)   \n\n上图中，**蓝色**的线框表示 `numbers` 协程，**栗色**的线框表示 `alphabets` 协程。**绿色**的线框表示主协程。**黑色**的线框合并了上述三个协程，向我们展示了该程序的工作原理。每个框顶部的 `0ms`，`250 ms` 的字符串表示以**毫秒**为单位的时间，在每个框底部的 `1`，`2`，`3` 表示输出。      \n\n蓝色的线框告诉我们在 250ms 的时候打印了`1`，在 `500ms` 的时候打印了`2`，以此类推。因此最后一个线框底部的输出：`1 a 2 3 b 4 c 5 d e main terminated` 也是整个程序的输出。上面的图像是很好理解的，您将能够了解该程序的工作原理。  \n\nGo协程的介绍就到这里。祝你有美好的一天！  \n希望你喜欢阅读。请留下宝贵的意见和反馈:)  ","meta":{"mtime":""}}}
</script>

    <script src="../tmp/book/624c24de5f335/asset/lodash/lodash.min.js?v=4.17.21"></script>

    <script src="../tmp/book/624c24de5f335/asset/react/react.production.min.js?v=17.0.2"></script>

    <script src="../tmp/book/624c24de5f335/asset/react-dom/react-dom.production.min.js?v=17.0.2"></script>

    <script src="../tmp/book/624c24de5f335/asset/reader/index.js?v=1.0.24"></script>

    <script src="../tmp/book/624c24de5f335/asset/plugins/comment/index.js?v=0.0.1"></script>

    <script src="../tmp/book/624c24de5f335/asset/plugins/highlight/index.js?v=1.0.0"></script>

    <script src="../tmp/book/624c24de5f335/asset/plugins/theme-classic/index.js?v=1.0.2"></script>

<script type="text/javascript">
    TopWrite.bootstrap();
</script>
</body>
</html>
