<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>如何编写 Go代码 - 万物联网服务平台</title>
    
    
    
    
</head>
<body>
<div id="root"></div>
<script type="application/payload+json">
{"id":"yWP4GW","summary":[{"id":"","title":"第0章 远程安装","articles":[]},{"id":"","title":"第1章 介绍和安装","articles":[{"title":"1 - 介绍和安装","ref":"\/docs\/golang_tutorial_01.md","path":"\/docs\/golang_tutorial_01.html","children":[]},{"title":"2 - Hello World ","ref":"\/docs\/golang_tutorial_02.md","path":"\/docs\/golang_tutorial_02.html","children":[]}]},{"id":"","title":"第2章 变量、类型和常量","articles":[{"title":"3 - 变量","ref":"\/docs\/golang_tutorial_03.md","path":"\/docs\/golang_tutorial_03.html","children":[]},{"title":"4 - 类型","ref":"\/docs\/golang_tutorial_04.md","path":"\/docs\/golang_tutorial_04.html","children":[]},{"title":"5 - 常量","ref":"\/docs\/golang_tutorial_05.md","path":"\/docs\/golang_tutorial_05.html","children":[]}]},{"id":"","title":"第3章 函数和包","articles":[{"title":"6 - 函数","ref":"\/docs\/golang_tutorial_06.md","path":"\/docs\/golang_tutorial_06.html","children":[]},{"title":"7 - 包","ref":"\/docs\/golang_tutorial_07.md","path":"\/docs\/golang_tutorial_07.html","children":[]}]},{"id":"","title":"第4章 条件和循环语句","articles":[{"title":"8 - if else 语句","ref":"\/docs\/golang_tutorial_08.md","path":"\/docs\/golang_tutorial_08.html","children":[]},{"title":"9 - 循环语句","ref":"\/docs\/golang_tutorial_09.md","path":"\/docs\/golang_tutorial_09.html","children":[]},{"title":"10 - switch语句","ref":"\/docs\/golang_tutorial_10.md","path":"\/docs\/golang_tutorial_10.html","children":[]}]},{"id":"","title":"第5章 数组、切片和变参函数","articles":[{"title":"11 - 数组和切片","ref":"\/docs\/golang_tutorial_11.md","path":"\/docs\/golang_tutorial_11.html","children":[]},{"title":"12 - 变 参函数","ref":"\/docs\/golang_tutorial_12.md","path":"\/docs\/golang_tutorial_12.html","children":[]}]},{"id":"","title":"第6章 更多的类型","articles":[{"title":"13 - Map","ref":"\/docs\/golang_tutorial_13.md","path":"\/docs\/golang_tutorial_13.html","children":[]},{"title":"14 - 字符串","ref":"\/docs\/golang_tutorial_14.md","path":"\/docs\/golang_tutorial_14.html","children":[]}]},{"id":"","title":"第7章 指针、结构体和方法","articles":[{"title":"15 - 指针","ref":"\/docs\/golang_tutorial_15.md","path":"\/docs\/golang_tutorial_15.html","children":[]},{"title":"16 -  结构体","ref":"\/docs\/golang_tutorial_16.md","path":"\/docs\/golang_tutorial_16.html","children":[]},{"title":"17 -  方法","ref":"\/docs\/golang_tutorial_17.md","path":"\/docs\/golang_tutorial_17.html","children":[]}]},{"id":"","title":"第8章 接口","articles":[]},{"id":"","title":"第9章 并发","articles":[{"title":" 21 - 协程","ref":"\/docs\/golang_tutorial_21.md","path":"\/docs\/golang_tutorial_21.html","children":[]}]},{"id":"","title":"第10章 面向对象编程","articles":[]},{"id":"","title":"第11章 延迟和错误处理","articles":[{"title":"35 - 读文件","ref":"\/docs\/golang_tutorial_35.md","path":"\/docs\/golang_tutorial_35.html","children":[]}]},{"id":"","title":"文档","articles":[{"title":"如何编写 Go代码","ref":"\/docs\/how_to_write_go_code.md","path":"\/docs\/how_to_write_go_code.html","children":[]}]}],"config":{"pluginsConfig":{"theme-default":{"auto_open":true,"navs":[{"title":"ThinkAPI","url":"https:\/\/docs.topthink.com\/think-api\/1835085"},{"title":"Tinywan","url":"https:\/\/market.topthink.com\/website"}]}},"title":"万物联网服务平台","plugins":["highlight","comment"],"theme":"classic"},"file":{"path":"\/docs\/how_to_write_go_code.html","content":"如何编写Go代码\n========================\n\n简介：介绍如何使用go命令获取、构建和安装包，命令和运行测试。  \n\n## 概述  \n\n> 目录  \n\n* 介绍  \n* 代码组织  \n  * 概观  \n  * 工作区  \n  * GOPATH环境变量  \n  * 导入路径  \n  * 你的第一个程序  \n  * 你的第一个库  \n* 包名称  \n* 测试  \n* 远程软件包  \n\n> 介绍  \n\n本文档演示了一个简单Go包的开发过程，并介绍了go工具，这是获取、构建和安装Go包和命令的标准方法。  \n\n该go工具要求您以特定方式组织您的代码。  \n\n## 代码组织  \n\n> 概观  \n\n请注意，这与其他编程环境不同，在这些编程环境中，每个项目都有一个单独的工作区，工作区与版本控制存储库紧密相关。  \n\n* Go程序员通常将他们所有的Go代码保存在一个工作区中。  \n* 工作区包含许多版本控制存储库 （例如，由Git管理）。  \n* 每个存储库都包含一个或多个包。  \n* 每个软件包由一个目录中的一个或多个Go源文件组成。  \n* 包的目录的路径决定了它的导入路径。  \n\n> 工作区  \n\n工作空间是一个目录层次结构，其根目录包含三个目录：  \n\n* src 包含Go源文件，  \n* pkg 包含包对象  \n* bin 包含可执行命令。  \n\n该go工具构建源包并将生成的二进制文件安装到pkg和bin目录。  \n\n该`src`子目录通常包含多个版本控制存储库（例如Git或Mercurial），用于跟踪一个或多个源包的开发。  \n\n为了让您了解工作空间在实践中的外观，下面是一个例子：  \n\n```golang\nbin\/\n    hello                          # 命令可执行文件\n    outyet                         # 命令可执行文件\npkg\/\n    linux_amd64\/\n        github.com\/golang\/example\/\n            stringutil.a           # 包对象\nsrc\/\n    github.com\/golang\/example\/\n        .git\/                      # Git存储库元数据\n\thello\/\n\t    hello.go               # 命令源\n\toutyet\/\n\t    main.go                # command source\n\t    main_test.go           # test source\n\tstringutil\/\n\t    reverse.go             # 包源码\n\t    reverse_test.go        # 测试源码\n    golang.org\/x\/image\/\n        .git\/                      # Git存储库元数据\n\tbmp\/\n\t    reader.go              # package source\n\t    writer.go              # package source\n    ... (many more repositories and packages omitted) ...\n```\n\n上面的树显示了一个包含两个存储库（example和image）的工作空间。该example库包含两个命令（hello 和outyet）和一个库（`stringutil`）。该image存储库包含该bmp包和其他几个包。  \n\n典型的工作空间包含许多包含许多包和命令的源代码库。大多数Go程序员将他们所有的Go源代码和依赖关系保存在一个工作区中。  \n\n命令和库由不同类型的源代码包构建而成。  \n\n> 第一个程序  \n\n要编译并运行一个简单的程序，首先选择一个包路径（我们将使用 `github.com\/user\/hello`）并在工作区内创建一个相应的包目录：  \n\n```bash\nmkdir $GOPATH\/src\/github.com\/user\/hello\n```\n\n接下来，创建一个名为hello.go该目录内的文件，其中包含以下Go代码。  \n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Printf(\"Hello, world.\\n\")\n}\n```\n\n现在，您可以使用该go工具构建和安装该程序  \n\n```golang\n$ go install github.com\/user\/hello \/\/ 编译包文件并且编译整个程序\n```\n\n请注意，您可以从系统上的任何位置运行此命令。该 go工具通过查找 `github.com\/user\/hello ` 指定的工作区内的程序包来查找源代码 `GOPATH`。  \n\n如果`go install`从软件包目录运行，也可以省略软件包路径：  \n\n```golang\n$ cd $GOPATH\/src\/github.com\/user\/hello\n$ go install\n```\n\n该命令构建`hello`命令，生成可执行的二进制文件。然后它将该二进制文件安装到工作空间的`bin`目录`hello`（或者在Windows下`hello.exe`）。在我们的例子中，那将是`$GOPATH\/bin\/hello`，这是`$HOME\/go\/bin\/hello`。  \n\n该`go`工具只会在发生错误时打印输出，因此如果这些命令不产生任何输出，它们将成功执行。  \n\n您现在可以通过在命令行键入完整路径来运行该程序：  \n\n```bash\n$ $GOPATH\/bin\/hello\nHello, world.\n```\n或者，如您添加`$GOPATH\/bin`到您的`PATH`，只需键入二进制名称：  \n\n```golang\n$ hello\nHello, world.\n```\n\n如果您正在使用源代码管理系统，现在应该是初始化存储库，添加文件并提交第一个更改的好时机。再一次，这一步是可选的：你不需要使用源代码控制来编写Go代码。  \n\n```bash\n$ cd $GOPATH\/src\/github.com\/user\/hello\n$ git init\nInitialized empty Git repository in \/home\/user\/work\/src\/github.com\/user\/hello\/.git\/\n$ git add hello.go\n$ git commit -m \"initial commit\"\n[master (root-commit) 0b4507d] initial commit\n 1 file changed, 1 insertion(+)\n  create mode 100644 hello.go\n$ git remote add origin https:\/\/github.com\/Tinywan\/hello.git\n$ git push -u origin master\n```\n将代码推送到远程存储库作为自己的练习。  \n\n> 你的第一库  \n\n我们来编写一个库并从`hello`程序中使用它。  \n\n再次，第一步是选择一个包路径（我们将使用 `github.com\/user\/stringutil`）并创建包目录：  \n\n```bash\n$ mkdir $GOPATH\/src\/github.com\/user\/stringutil\n```\n\n接下来，使用以下内容创建一个名称在该目录中的文件。  \n\n```golang\n\/\/ Package stringutil contains utility functions for working with strings.\npackage stringutil\n\n\/\/ Reverse returns its argument string reversed rune-wise left to right.\nfunc Reverse(s string) string {\n\tr := []rune(s)\n\tfor i, j := 0, len(r)-1; i < len(r)\/2; i, j = i+1, j-1 {\n\t\tr[i], r[j] = r[j], r[i]\n\t}\n\treturn string(r)\n}\n```\n\n现在，测试该软件包是用下面用`go build`命令进行代码编译：  \n\n```bash\n$ go build github.com\/user\/stringutil  \/\/ 测试编译，检查编译是否有编译错误\n```\n\n或者，如果您在包的源目录中工作，只需：  \n\n```bash\n$ go build \n```\n\n这不会产生输出文件。为此，必须使用`go install`将包对象放置在工作空间的`pkg`目录中的方法。  \n\n确认stringutil软件包构建完成后，修改原始文件`hello.go`（位于 `$GOPATH\/src\/github.com\/user\/hello`）以使用它：  \n\n```golang\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com\/user\/stringutil\"\n)\n\nfunc main() {\n\tfmt.Printf(stringutil.Reverse(\"!oG ,olleH\"))\n}\n```\n\n无论何时该go工具**安装包或二进制文件**，**它也会安装它所具有的任何依赖关系**。所以当你安装hello程序  \n\n```bash\n$ go install github.com\/user\/hello\n```\n\n该`stringutil`包也将自动安装。  \n\n运行该程序的新版本，您应该看到一条新的反转消息：  \n\n```bash\n$ hello\nHello, Go!\n```\n\n完成上述步骤后，您的工作空间应如下所示：  \n\n```bash\nbin\/\n    hello                 # command executable\npkg\/\n    linux_amd64\/          # this will reflect your OS and architecture\n        github.com\/user\/\n            stringutil.a  # package object\nsrc\/\n    github.com\/user\/\n        hello\/\n            hello.go      # command source\n        stringutil\/\n            reverse.go    # package source\n```\n\n请注意，`go install`将`stringutil.a`对象放置在`pkg\/linux_amd64`镜像源目录中的目录中。这样未来的`go`工具调用可以找到包对象并避免不必要地重新编译包。该`linux_amd64`部分有助于交叉编译，并将反映您的系统的操作系统和体系结构。  \n\n**Go命令可执行文件是静态链接的**，包对象不需要存在来运行Go程序。  \n\n> 包名称  \n\nGo源文件中的第一条语句必须是  \n\n```bash\npackage name\n```\n\n这里`name`是对进口的包的默认名称。（包中的所有文件都必须使用相同的文件`name`）\n\nGo的惯例是包名称是导入路径的最后一个元素：`crypto\/rot13`应该命名导入为“ ” 的包rot13。\n\n可执行命令必须始终使用`package main`。  \n\n没有要求软件包名称在链接到一个二进制文件的所有软件包中唯一，**只需要导入路径（它们的完整文件名）是唯一的**。  \n\n请参阅[Effective Go](http:\/\/127.0.0.1:8080\/doc\/effective_go.html#names)详细了解Go的命名约定。  \n\n> 测试  \n\nGo有一个由`go test `命令和`testing`包组成的轻量级测试框架。  \n\n您通过创建一个名称以文件名结尾的文件来编写一个测试`_test.go` ，其中包含以TestXXX签名 命名的函数`func (t *testing.T)`。测试框架运行每个这样的功能; 如果函数调用失败函数（如t.Error或）` t.Fail`，则认为测试失败。  \n\n`stringutil`通过创建`$GOPATH\/src\/github.com\/user\/stringutil\/reverse_test.go`包含以下Go代码的文件 向测试包 添加测试。  \n\n```golang\npackage stringutil\n\nimport \"testing\"\n\nfunc TestReverse(t *testing.T) {\n\tcases := []struct {\n\t\tin, want string\n\t}{\n\t\t{\"Hello, world\", \"dlrow ,olleH\"},\n\t\t{\"Hello, 世界\", \"界世 ,olleH\"},\n\t\t{\"\", \"\"},\n\t}\n\tfor _, c := range cases {\n\t\tgot := Reverse(c.in)\n\t\tif got != c.want {\n\t\t\tt.Errorf(\"Reverse(%q) == %q, want %q\", c.in, got, c.want)\n\t\t}\n\t}\n}\n```\n\n然后运行测试`go test`：  \n\n```bash\n$ go test github.com\/user\/stringutil\nok  \tgithub.com\/user\/stringutil 0.165s\n```\n\n与往常一样，如果您正在go从软件包目录运行该工具，则可以省略软件包路径：\n\n```bash\n$ go test\nok  \tgithub.com\/user\/stringutil 0.165s\n```\n运行`go help test`并查看 测试包文档以获取更多详细信息。  \n\n> 远程软件包  \n\n导入路径可以描述如何使用Git或Mercurial等版本控制系统获取软件包源代码。该go工具使用此属性从远程存储库自动获取软件包。例如，本文档中描述的示例也保存在GitHub托管的Git存储库中` github.com\/golang\/example`。如果您在存储库的导入路径中包含存储库URL，` go get`将自动获取，构建和安装它：  \n\n```bash\n$ go get github.com\/golang\/example\/hello\n$ $GOPATH\/bin\/hello\nHello, Go examples!\n```\n\n如果指定的软件包不在工作区中，`go get `则将其放入由指定的第一个工作区内`GOPATH`。（如果包已经存在，则`go get`跳过远程抓取并且行为与`go install`相同）  \n\n发出上述`go get`命令后，工作空间目录树现在应该如下所示：  \n\n```golang\nbin\/\n    hello                           # command executable\npkg\/\n    linux_amd64\/\n        github.com\/golang\/example\/\n            stringutil.a            # package object\n        github.com\/user\/\n            stringutil.a            # package object\nsrc\/\n    github.com\/golang\/example\/\n\t.git\/                       # Git repository metadata\n        hello\/\n            hello.go                # command source\n        stringutil\/\n            reverse.go              # package source\n            reverse_test.go         # test source\n    github.com\/user\/\n        hello\/\n            hello.go                # command source\n        stringutil\/\n            reverse.go              # package source\n            reverse_test.go         # test source\n```\n\nhello在GitHub上托管的命令取决于`stringutil`同一个存储库中的软件包。在导入`hello.go`文件中使用相同的导入路径约定，所以` go get`命令能够找到并安装相关的包了。  \n\n导入`“github.com\/golang\/example\/stringutil”`这个约定是让你的Go软件包可供其他人使用的最简单的方法。在转到维基 和`godoc.org` 提供外部围棋项目清单。\n\n有关在go工具中使用远程存储库的更多信息，请参阅 [go help importpath](http:\/\/127.0.0.1:8080\/cmd\/go\/#hdr-Remote_import_paths)。","meta":{"mtime":""}}}
</script>

    <script src="../tmp/book/624c24de5f335/asset/lodash/lodash.min.js?v=4.17.21"></script>

    <script src="../tmp/book/624c24de5f335/asset/react/react.production.min.js?v=17.0.2"></script>

    <script src="../tmp/book/624c24de5f335/asset/react-dom/react-dom.production.min.js?v=17.0.2"></script>

    <script src="../tmp/book/624c24de5f335/asset/reader/index.js?v=1.0.24"></script>

    <script src="../tmp/book/624c24de5f335/asset/plugins/comment/index.js?v=0.0.1"></script>

    <script src="../tmp/book/624c24de5f335/asset/plugins/highlight/index.js?v=1.0.0"></script>

    <script src="../tmp/book/624c24de5f335/asset/plugins/theme-classic/index.js?v=1.0.2"></script>

<script type="text/javascript">
    TopWrite.bootstrap();
</script>
</body>
</html>
